/**

Generated by the following Solidity interface...
```solidity
interface MultiVerse {
    type Resolution is uint8;

    error InvalidMarketState();
    error InvalidResolution();
    error InvalidVerse();
    error MarketAlreadyOpened();

    event Combined(address indexed user, address indexed asset, bytes32 indexed marketHash, uint256 amount, address yesVerse, address noVerse);
    event MarketOpened(bytes32 indexed marketHash, bytes32 indexed questionHash, uint32 resolutionDeadline, address indexed oracle);
    event MarketResolved(bytes32 indexed marketHash, Resolution resolution);
    event Redeemed(address indexed user, address indexed verse, bytes32 indexed marketHash, uint256 amount, uint256 redeemedAmount);
    event Split(address indexed user, address indexed asset, bytes32 indexed marketHash, uint256 amount, address yesVerse, address noVerse);
    event VerseTokensCreated(bytes32 indexed marketHash, address indexed asset, address yesVerse, address noVerse);

    function combine(address asset, uint256 amount, bytes32 marketHash) external;
    function create(address asset, bytes32 marketHash) external returns (address yesVerse, address noVerse);
    function getVerseAddress(address asset, bytes32 marketHash) external view returns (address yesVerse, address noVerse);
    function isVerse(address verse) external view returns (bool);
    function markets(bytes32 marketHash) external view returns (uint32 resolutionDeadline, address oracle, bytes32 questionHash);
    function open(bytes32 questionHash, uint32 resolutionDeadline, address oracle) external;
    function redeem(address verse, uint256 amount) external returns (uint256 redeemedAmount);
    function resolutions(bytes32 marketHash) external view returns (Resolution);
    function resolve(bytes32 marketHash) external;
    function split(address asset, uint256 amount, bytes32 marketHash) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "combine",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "create",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "yesVerse",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "noVerse",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getVerseAddress",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "yesVerse",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "noVerse",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isVerse",
    "inputs": [
      {
        "name": "verse",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "markets",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "resolutionDeadline",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "oracle",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "questionHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "open",
    "inputs": [
      {
        "name": "questionHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "resolutionDeadline",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "oracle",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "redeem",
    "inputs": [
      {
        "name": "verse",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "redeemedAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolutions",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum MultiVerse.Resolution"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "resolve",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "split",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Combined",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "asset",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "yesVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "noVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MarketOpened",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "questionHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "resolutionDeadline",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "oracle",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MarketResolved",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "resolution",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum MultiVerse.Resolution"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Redeemed",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "verse",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "redeemedAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Split",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "asset",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "yesVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "noVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "VerseTokensCreated",
    "inputs": [
      {
        "name": "marketHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "asset",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "yesVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "noVerse",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "InvalidMarketState",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidResolution",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidVerse",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MarketAlreadyOpened",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MultiVerse {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b5061257a8061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061009b575f3560e01c80639ba730a9116100635780639ba730a91461017a578063a3def9231461018d578063c2a33c1d146101c0578063d4b06fb8146101d3578063e973955014610202575f5ffd5b80631e9a69501461009f57806341055a76146100c55780635c23bdf5146100da5780637183d24a146100ed5780637564912b14610110575b5f5ffd5b6100b26100ad3660046111df565b610215565b6040519081526020015b60405180910390f35b6100d86100d3366004611209565b61062a565b005b6100d86100e836600461123b565b6108e1565b6101006100fb366004611252565b610a46565b60405190151581526020016100bc565b61015061011e36600461123b565b5f602081905290815260409020805460019091015463ffffffff82169164010000000090046001600160a01b03169083565b6040805163ffffffff90941684526001600160a01b039092166020840152908201526060016100bc565b6100d8610188366004611209565b610bf1565b6101a061019b3660046111df565b610dcd565b604080516001600160a01b039384168152929091166020830152016100bc565b6100d86101ce366004611274565b610f0f565b6101f56101e136600461123b565b60016020525f908152604090205460ff1681565b6040516100bc91906112cf565b6101a06102103660046111df565b61104c565b5f5f604051602001610230906259455360e81b815260030190565b60405160208183030381529060405280519060200120846001600160a01b03166395d89b416040518163ffffffff1660e01b81526004015f60405180830381865afa158015610281573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102a89190810190611309565b6040516020016102b891906113d3565b604051602081830303815290604052805190602001201490505f846001600160a01b031663c0474d0b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061033291906113de565b90505f856001600160a01b0316634800d97f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610371573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061039591906113f5565b90506103a2838284611070565b6001600160a01b0316866001600160a01b0316146103d3576040516340fe50fd60e01b815260040160405180910390fd5b60025f8381526001602052604090205460ff1660048111156103f7576103f76112bb565b1480156104015750825b1561040e5784935061049e565b60035f8381526001602052604090205460ff166004811115610432576104326112bb565b14801561043d575082155b1561044a5784935061049e565b60045f8381526001602052604090205460ff16600481111561046e5761046e6112bb565b036104855761047e600286611410565b935061049e565b604051637256f64560e11b815260040160405180910390fd5b6040516323b872dd60e01b81526001600160a01b038716906323b872dd906104ce90339030908a9060040161142f565b6020604051808303815f875af11580156104ea573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061050e9190611453565b50604051632770a7eb60e21b8152306004820152602481018690526001600160a01b03871690639dc29fac906044015f604051808303815f87803b158015610554575f5ffd5b505af1158015610566573d5f5f3e3d5ffd5b505060405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038416925063a9059cbb91506044016020604051808303815f875af11580156105b4573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105d89190611453565b50604080518681526020810186905283916001600160a01b0389169133917fae1d804a86b6ba2a7725d9824d4ccb4e7f9a55e7a1bf4379c26692ce5ad00665910160405180910390a450505092915050565b60015f8281526001602052604090205460ff16600481111561064e5761064e6112bb565b1461066c5760405163239dd4ad60e11b815260040160405180910390fd5b5f5f610678858461104c565b6040516323b872dd60e01b815291935091506001600160a01b038316906323b872dd906106ad9033903090899060040161142f565b6020604051808303815f875af11580156106c9573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106ed9190611453565b506040516323b872dd60e01b81526001600160a01b038216906323b872dd9061071e9033903090899060040161142f565b6020604051808303815f875af115801561073a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061075e9190611453565b50604051632770a7eb60e21b8152306004820152602481018590526001600160a01b03831690639dc29fac906044015f604051808303815f87803b1580156107a4575f5ffd5b505af11580156107b6573d5f5f3e3d5ffd5b5050604051632770a7eb60e21b8152306004820152602481018790526001600160a01b0384169250639dc29fac91506044015f604051808303815f87803b1580156107ff575f5ffd5b505af1158015610811573d5f5f3e3d5ffd5b505060405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038816925063a9059cbb91506044016020604051808303815f875af115801561085f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108839190611453565b50604080518581526001600160a01b03848116602083015283811692820192909252849187169033907f9a853bfbdd6034e0e7553bb8ec7789b2603dcccb5759cf390a7a601c0b6da003906060015b60405180910390a45050505050565b60015f8281526001602052604090205460ff166004811115610905576109056112bb565b146109235760405163239dd4ad60e11b815260040160405180910390fd5b5f8181526020819052604081205463ffffffff164210610945575060046109d8565b5f828152602081905260408082205490516301f46b2960e11b8152600481018590526401000000009091046001600160a01b0316906303e8d652906024016020604051808303815f875af115801561099f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109c39190611453565b9050806109d15760036109d4565b60025b9150505b5f8281526001602081905260409091208054839260ff1990911690836004811115610a0557610a056112bb565b0217905550817ff34984473148051bc1bdf1be6ecc462d7b228d591058a8a27977b84770b738b982604051610a3a91906112cf565b60405180910390a25050565b5f5f826001600160a01b031663c0474d0b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a84573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610aa891906113de565b90505f836001600160a01b0316634800d97f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae7573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b0b91906113f5565b90505f604051602001610b27906259455360e81b815260030190565b60405160208183030381529060405280519060200120856001600160a01b03166395d89b416040518163ffffffff1660e01b81526004015f60405180830381865afa158015610b78573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610b9f9190810190611309565b604051602001610baf91906113d3565b60405160208183030381529060405280519060200120149050610bd3818385611070565b6001600160a01b0316856001600160a01b0316149350505050919050565b60015f8281526001602052604090205460ff166004811115610c1557610c156112bb565b14610c335760405163239dd4ad60e11b815260040160405180910390fd5b6040516323b872dd60e01b81526001600160a01b038416906323b872dd90610c639033903090879060040161142f565b6020604051808303815f875af1158015610c7f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ca39190611453565b505f5f610cb0858461104c565b6040516340c10f1960e01b81523360048201526024810187905291935091506001600160a01b038316906340c10f19906044015f604051808303815f87803b158015610cfa575f5ffd5b505af1158015610d0c573d5f5f3e3d5ffd5b50506040516340c10f1960e01b8152336004820152602481018790526001600160a01b03841692506340c10f1991506044015f604051808303815f87803b158015610d55575f5ffd5b505af1158015610d67573d5f5f3e3d5ffd5b5050505082856001600160a01b0316336001600160a01b03167f8fb8a329bc68853568e0dd27c6aee2e361a1f07892cf65ab49cc2f30cd21c3c58786866040516108d2939291909283526001600160a01b03918216602084015216604082015260600190565b5f5f828484604051610dde906111bb565b608080825260039082018190526259657360e81b60a083015260c0602083018190528201526259455360e81b60e08201526001600160a01b0390921660408301526060820152610100018190604051809103905ff5905080158015610e45573d5f5f3e3d5ffd5b509150828484604051610e57906111bb565b60808082526002908201819052614e6f60f01b60a083015260c060208301819052820152614e4f60f01b60e08201526001600160a01b0390921660408301526060820152610100018190604051809103905ff5905080158015610ebc573d5f5f3e3d5ffd5b50604080516001600160a01b0385811682528381166020830152825193945087169286927f9e431caef5753e3e939653fc056c910725980029b3653db5a36bebca71d6bc2c928290030190a39250929050565b604080516020810185905263ffffffff8416918101919091526001600160a01b03821660608201525f9060800160408051601f19818403018152919052805160209091012090505f5f8281526001602052604090205460ff166004811115610f7957610f796112bb565b14610f97576040516337a5bd9b60e11b815260040160405180910390fd5b5f818152600160208181526040808420805460ff191684179055805160608101825263ffffffff8881168083526001600160a01b038981168487018181528587018e81528b8b528a89529987902095518654915195166001600160c01b0319909116176401000000009490921693909302178355955191909401558051938452519192879285927f094eba69d7ca9dfafa34c896067fc8e19395a610e47deb8b25b21b87bec32a34928290030190a450505050565b5f5f61105a60018585611070565b91506110675f8585611070565b90509250929050565b5f5f60405180602001611082906111bb565b601f1982820381018352601f90910116604052856110ba57604051806040016040528060028152602001614e6f60f01b8152506110d7565b6040518060400160405280600381526020016259657360e81b8152505b866110fc57604051806040016040528060028152602001614e4f60f01b815250611119565b6040518060400160405280600381526020016259455360e81b8152505b868660405160200161112e94939291906114a0565b60408051601f198184030181529082905261114c92916020016114e1565b60408051808303601f1901815282825280516020918201206001600160f81b0319828501523060601b6bffffffffffffffffffffffff19166021850152603584019690965260558084019690965281518084039096018652607590920190528351930192909220949350505050565b611047806114fe83390190565b6001600160a01b03811681146111dc575f5ffd5b50565b5f5f604083850312156111f0575f5ffd5b82356111fb816111c8565b946020939093013593505050565b5f5f5f6060848603121561121b575f5ffd5b8335611226816111c8565b95602085013595506040909401359392505050565b5f6020828403121561124b575f5ffd5b5035919050565b5f60208284031215611262575f5ffd5b813561126d816111c8565b9392505050565b5f5f5f60608486031215611286575f5ffd5b83359250602084013563ffffffff811681146112a0575f5ffd5b915060408401356112b0816111c8565b809150509250925092565b634e487b7160e01b5f52602160045260245ffd5b60208101600583106112ef57634e487b7160e01b5f52602160045260245ffd5b91905290565b634e487b7160e01b5f52604160045260245ffd5b5f60208284031215611319575f5ffd5b815167ffffffffffffffff81111561132f575f5ffd5b8201601f8101841361133f575f5ffd5b805167ffffffffffffffff811115611359576113596112f5565b604051601f8201601f19908116603f0116810167ffffffffffffffff81118282101715611388576113886112f5565b60405281815282820160200186101561139f575f5ffd5b8160208401602083015e5f91810160200191909152949350505050565b5f81518060208401855e5f93019283525090919050565b5f61126d82846113bc565b5f602082840312156113ee575f5ffd5b5051919050565b5f60208284031215611405575f5ffd5b815161126d816111c8565b5f8261142a57634e487b7160e01b5f52601260045260245ffd5b500490565b6001600160a01b039384168152919092166020820152604081019190915260600190565b5f60208284031215611463575f5ffd5b8151801515811461126d575f5ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b608081525f6114b26080830187611472565b82810360208401526114c48187611472565b6001600160a01b0395909516604084015250506060015292915050565b5f6114f56114ef83866113bc565b846113bc565b94935050505056fe60c060405234801561000f575f5ffd5b5060405161104738038061104783398101604081905261002e91610143565b5f6100398582610252565b5060016100468482610252565b506001600160a01b03821660805260a08190526100623361006b565b5050505061030c565b6001600160a01b0316638b78c6d819819055805f7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a350565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126100c9575f5ffd5b81516001600160401b038111156100e2576100e26100a6565b604051601f8201601f19908116603f011681016001600160401b0381118282101715610110576101106100a6565b604052818152838201602001851015610127575f5ffd5b8160208501602083015e5f918101602001919091529392505050565b5f5f5f5f60808587031215610156575f5ffd5b84516001600160401b0381111561016b575f5ffd5b610177878288016100ba565b602087015190955090506001600160401b03811115610194575f5ffd5b6101a0878288016100ba565b604087015190945090506001600160a01b03811681146101be575f5ffd5b6060959095015193969295505050565b600181811c908216806101e257607f821691505b60208210810361020057634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561024d57805f5260205f20601f840160051c8101602085101561022b5750805b601f840160051c820191505b8181101561024a575f8155600101610237565b50505b505050565b81516001600160401b0381111561026b5761026b6100a6565b61027f8161027984546101ce565b84610206565b6020601f8211600181146102b1575f831561029a5750848201515b5f19600385901b1c1916600184901b17845561024a565b5f84815260208120601f198516915b828110156102e057878501518255602094850194600190920191016102c0565b50848210156102fd57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b60805160a051610d1a61032d5f395f61036e01525f6102470152610d1a5ff3fe60806040526004361061013c575f3560e01c8063715018a6116100b3578063c0474d0b1161006d578063c0474d0b1461035d578063d505accf14610390578063dd62ed3e146103af578063f04e283e146103ce578063f2fde38b146103e1578063fee81cf4146103f4575f5ffd5b8063715018a6146102ba5780637ecebe00146102c25780638da5cb5b146102f357806395d89b411461030b5780639dc29fac1461031f578063a9059cbb1461033e575f5ffd5b8063313ce56711610104578063313ce567146101e85780633644e5151461020357806340c10f19146102175780634800d97f1461023657806354d1f13d1461028157806370a0823114610289575f5ffd5b806306fdde0314610140578063095ea7b31461016a57806318160ddd1461019957806323b872dd146101bf57806325692962146101de575b5f5ffd5b34801561014b575f5ffd5b50610154610425565b6040516101619190610b1c565b60405180910390f35b348015610175575f5ffd5b50610189610184366004610b6c565b6104b4565b6040519015158152602001610161565b3480156101a4575f5ffd5b506805345cdf77eb68f44c545b604051908152602001610161565b3480156101ca575f5ffd5b506101896101d9366004610b94565b610534565b6101e66105f0565b005b3480156101f3575f5ffd5b5060405160128152602001610161565b34801561020e575f5ffd5b506101b161063d565b348015610222575f5ffd5b506101e6610231366004610b6c565b6106b9565b348015610241575f5ffd5b506102697f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610161565b6101e66106cf565b348015610294575f5ffd5b506101b16102a3366004610bce565b6387a211a2600c9081525f91909152602090205490565b6101e6610708565b3480156102cd575f5ffd5b506101b16102dc366004610bce565b6338377508600c9081525f91909152602090205490565b3480156102fe575f5ffd5b50638b78c6d81954610269565b348015610316575f5ffd5b5061015461071b565b34801561032a575f5ffd5b506101e6610339366004610b6c565b61072a565b348015610349575f5ffd5b50610189610358366004610b6c565b61073c565b348015610368575f5ffd5b506101b17f000000000000000000000000000000000000000000000000000000000000000081565b34801561039b575f5ffd5b506101e66103aa366004610bee565b6107a0565b3480156103ba575f5ffd5b506101b16103c9366004610c5b565b610954565b6101e66103dc366004610bce565b610998565b6101e66103ef366004610bce565b6109d5565b3480156103ff575f5ffd5b506101b161040e366004610bce565b63389a75e1600c9081525f91909152602090205490565b60605f805461043390610c8c565b80601f016020809104026020016040519081016040528092919081815260200182805461045f90610c8c565b80156104aa5780601f10610481576101008083540402835291602001916104aa565b820191905f5260205f20905b81548152906001019060200180831161048d57829003601f168201915b5050505050905090565b5f6001600160a01b0383166e22d473030f116ddee9f6b43ac78ba318821915176104e557633f68539a5f526004601cfd5b82602052637f5e9f20600c52335f52816034600c2055815f52602c5160601c337f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560205fa35060015b92915050565b5f8360601b6e22d473030f116ddee9f6b43ac78ba333146105895733602052637f5e9f208117600c526034600c2080548019156105865780851115610580576313be252b5f526004601cfd5b84810382555b50505b6387a211a28117600c526020600c208054808511156105af5763f4d678b85f526004601cfd5b84810382555050835f526020600c208381540181555082602052600c5160601c8160601c5f516020610cc55f395f51905f52602080a3505060019392505050565b5f6202a30067ffffffffffffffff164201905063389a75e1600c52335f52806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d5f5fa250565b5f80610647610425565b805190602001209050604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f815260208101929092527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc69082015246606082015230608082015260a09020919050565b6106c16109fb565b6106cb8282610a15565b5050565b63389a75e1600c52335f525f6020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c925f5fa2565b6107106109fb565b6107195f610a7e565b565b60606001805461043390610c8c565b6107326109fb565b6106cb8282610abb565b5f6387a211a2600c52335f526020600c208054808411156107645763f4d678b85f526004601cfd5b83810382555050825f526020600c208281540181555081602052600c5160601c335f516020610cc55f395f51905f52602080a350600192915050565b6001600160a01b0386166e22d473030f116ddee9f6b43ac78ba318851915176107d057633f68539a5f526004601cfd5b5f6107d9610425565b8051906020012090507fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc64286101561081857631a15a3cc5f526004601cfd5b6040518960601b60601c99508860601b60601c985065383775081901600e52895f526020600c2080547f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f835284602084015283604084015246606084015230608084015260a08320602e527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c983528b60208401528a60408401528960608401528060808401528860a084015260c08320604e526042602c205f528760ff16602052866040528560605260208060805f60015afa8c3d51146109005763ddafbaef5f526004601cfd5b0190556303faf4f960a51b89176040526034602c20889055888a7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602060608501a360405250505f60605250505050505050565b5f6e22d473030f116ddee9f6b43ac78ba2196001600160a01b0383160161097d57505f1961052e565b50602052637f5e9f20600c9081525f91909152603490205490565b6109a06109fb565b63389a75e1600c52805f526020600c2080544211156109c657636f5e88185f526004601cfd5b5f90556109d281610a7e565b50565b6109dd6109fb565b8060601b6109f257637448fbae5f526004601cfd5b6109d281610a7e565b638b78c6d819543314610719576382b429005f526004601cfd5b6805345cdf77eb68f44c5481810181811015610a385763e5cfe9575f526004601cfd5b806805345cdf77eb68f44c5550506387a211a2600c52815f526020600c208181540181555080602052600c5160601c5f5f516020610cc55f395f51905f52602080a35050565b638b78c6d81980546001600160a01b039092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a355565b6387a211a2600c52815f526020600c20805480831115610ae25763f4d678b85f526004601cfd5b82900390556805345cdf77eb68f44c805482900390555f8181526001600160a01b0383165f516020610cc55f395f51905f52602083a35050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b0381168114610b67575f5ffd5b919050565b5f5f60408385031215610b7d575f5ffd5b610b8683610b51565b946020939093013593505050565b5f5f5f60608486031215610ba6575f5ffd5b610baf84610b51565b9250610bbd60208501610b51565b929592945050506040919091013590565b5f60208284031215610bde575f5ffd5b610be782610b51565b9392505050565b5f5f5f5f5f5f5f60e0888a031215610c04575f5ffd5b610c0d88610b51565b9650610c1b60208901610b51565b95506040880135945060608801359350608088013560ff81168114610c3e575f5ffd5b9699959850939692959460a0840135945060c09093013592915050565b5f5f60408385031215610c6c575f5ffd5b610c7583610b51565b9150610c8360208401610b51565b90509250929050565b600181811c90821680610ca057607f821691505b602082108103610cbe57634e487b7160e01b5f52602260045260245ffd5b5091905056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220f2558ad4460ca00ebebab8d02372dd6b027f19de7bd9d732ad74c5cf24635f4564736f6c634300081e0033a2646970667358221220919de7b4590df56bc11aeb304fa29d7b44145f3508341dc0a20c84eeab358d1564736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa%z\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x9BW_5`\xE0\x1C\x80c\x9B\xA70\xA9\x11a\0cW\x80c\x9B\xA70\xA9\x14a\x01zW\x80c\xA3\xDE\xF9#\x14a\x01\x8DW\x80c\xC2\xA3<\x1D\x14a\x01\xC0W\x80c\xD4\xB0o\xB8\x14a\x01\xD3W\x80c\xE9s\x95P\x14a\x02\x02W__\xFD[\x80c\x1E\x9AiP\x14a\0\x9FW\x80cA\x05Zv\x14a\0\xC5W\x80c\\#\xBD\xF5\x14a\0\xDAW\x80cq\x83\xD2J\x14a\0\xEDW\x80cud\x91+\x14a\x01\x10W[__\xFD[a\0\xB2a\0\xAD6`\x04a\x11\xDFV[a\x02\x15V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xD8a\0\xD36`\x04a\x12\tV[a\x06*V[\0[a\0\xD8a\0\xE86`\x04a\x12;V[a\x08\xE1V[a\x01\0a\0\xFB6`\x04a\x12RV[a\nFV[`@Q\x90\x15\x15\x81R` \x01a\0\xBCV[a\x01Pa\x01\x1E6`\x04a\x12;V[_` \x81\x90R\x90\x81R`@\x90 \x80T`\x01\x90\x91\x01Tc\xFF\xFF\xFF\xFF\x82\x16\x91d\x01\0\0\0\0\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90\x83V[`@\x80Qc\xFF\xFF\xFF\xFF\x90\x94\x16\x84R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16` \x84\x01R\x90\x82\x01R``\x01a\0\xBCV[a\0\xD8a\x01\x886`\x04a\x12\tV[a\x0B\xF1V[a\x01\xA0a\x01\x9B6`\x04a\x11\xDFV[a\r\xCDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\0\xBCV[a\0\xD8a\x01\xCE6`\x04a\x12tV[a\x0F\x0FV[a\x01\xF5a\x01\xE16`\x04a\x12;V[`\x01` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[`@Qa\0\xBC\x91\x90a\x12\xCFV[a\x01\xA0a\x02\x106`\x04a\x11\xDFV[a\x10LV[__`@Q` \x01a\x020\x90bYES`\xE8\x1B\x81R`\x03\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x84`\x01`\x01`\xA0\x1B\x03\x16c\x95\xD8\x9BA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\x81W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x02\xA8\x91\x90\x81\x01\x90a\x13\tV[`@Q` \x01a\x02\xB8\x91\x90a\x13\xD3V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14\x90P_\x84`\x01`\x01`\xA0\x1B\x03\x16c\xC0GM\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\x0EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x032\x91\x90a\x13\xDEV[\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16cH\0\xD9\x7F`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03qW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\x95\x91\x90a\x13\xF5V[\x90Pa\x03\xA2\x83\x82\x84a\x10pV[`\x01`\x01`\xA0\x1B\x03\x16\x86`\x01`\x01`\xA0\x1B\x03\x16\x14a\x03\xD3W`@Qc@\xFEP\xFD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x03\xF7Wa\x03\xF7a\x12\xBBV[\x14\x80\x15a\x04\x01WP\x82[\x15a\x04\x0EW\x84\x93Pa\x04\x9EV[`\x03_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x042Wa\x042a\x12\xBBV[\x14\x80\x15a\x04=WP\x82\x15[\x15a\x04JW\x84\x93Pa\x04\x9EV[`\x04_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x04nWa\x04na\x12\xBBV[\x03a\x04\x85Wa\x04~`\x02\x86a\x14\x10V[\x93Pa\x04\x9EV[`@QcrV\xF6E`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c#\xB8r\xDD\x90a\x04\xCE\x903\x900\x90\x8A\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x04\xEAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x0E\x91\x90a\x14SV[P`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x86\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\x9D\xC2\x9F\xAC\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x05TW__\xFD[PZ\xF1\x15\x80\x15a\x05fW=__>=_\xFD[PP`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc\xA9\x05\x9C\xBB\x91P`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x05\xB4W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xD8\x91\x90a\x14SV[P`@\x80Q\x86\x81R` \x81\x01\x86\x90R\x83\x91`\x01`\x01`\xA0\x1B\x03\x89\x16\x913\x91\x7F\xAE\x1D\x80J\x86\xB6\xBA*w%\xD9\x82ML\xCBN\x7F\x9AU\xE7\xA1\xBFCy\xC2f\x92\xCEZ\xD0\x06e\x91\x01`@Q\x80\x91\x03\x90\xA4PPP\x92\x91PPV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x06NWa\x06Na\x12\xBBV[\x14a\x06lW`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__a\x06x\x85\x84a\x10LV[`@Qc#\xB8r\xDD`\xE0\x1B\x81R\x91\x93P\x91P`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c#\xB8r\xDD\x90a\x06\xAD\x903\x900\x90\x89\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x06\xC9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\xED\x91\x90a\x14SV[P`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c#\xB8r\xDD\x90a\x07\x1E\x903\x900\x90\x89\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x07:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07^\x91\x90a\x14SV[P`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x85\x90R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\x9D\xC2\x9F\xAC\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x07\xA4W__\xFD[PZ\xF1\x15\x80\x15a\x07\xB6W=__>=_\xFD[PP`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc\x9D\xC2\x9F\xAC\x91P`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x07\xFFW__\xFD[PZ\xF1\x15\x80\x15a\x08\x11W=__>=_\xFD[PP`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x88\x16\x92Pc\xA9\x05\x9C\xBB\x91P`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x08_W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a\x14SV[P`@\x80Q\x85\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16` \x83\x01R\x83\x81\x16\x92\x82\x01\x92\x90\x92R\x84\x91\x87\x16\x903\x90\x7F\x9A\x85;\xFB\xDD`4\xE0\xE7U;\xB8\xECw\x89\xB2`=\xCC\xCBWY\xCF9\nz`\x1C\x0Bm\xA0\x03\x90``\x01[`@Q\x80\x91\x03\x90\xA4PPPPPV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\t\x05Wa\t\x05a\x12\xBBV[\x14a\t#W`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81\x81R` \x81\x90R`@\x81 Tc\xFF\xFF\xFF\xFF\x16B\x10a\tEWP`\x04a\t\xD8V[_\x82\x81R` \x81\x90R`@\x80\x82 T\x90Qc\x01\xF4k)`\xE1\x1B\x81R`\x04\x81\x01\x85\x90Rd\x01\0\0\0\0\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x03\xE8\xD6R\x90`$\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\t\x9FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xC3\x91\x90a\x14SV[\x90P\x80a\t\xD1W`\x03a\t\xD4V[`\x02[\x91PP[_\x82\x81R`\x01` \x81\x90R`@\x90\x91 \x80T\x83\x92`\xFF\x19\x90\x91\x16\x90\x83`\x04\x81\x11\x15a\n\x05Wa\n\x05a\x12\xBBV[\x02\x17\x90UP\x81\x7F\xF3I\x84G1H\x05\x1B\xC1\xBD\xF1\xBEn\xCCF-{\"\x8DY\x10X\xA8\xA2yw\xB8Gp\xB78\xB9\x82`@Qa\n:\x91\x90a\x12\xCFV[`@Q\x80\x91\x03\x90\xA2PPV[__\x82`\x01`\x01`\xA0\x1B\x03\x16c\xC0GM\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x84W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xA8\x91\x90a\x13\xDEV[\x90P_\x83`\x01`\x01`\xA0\x1B\x03\x16cH\0\xD9\x7F`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xE7W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\x0B\x91\x90a\x13\xF5V[\x90P_`@Q` \x01a\x0B'\x90bYES`\xE8\x1B\x81R`\x03\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x85`\x01`\x01`\xA0\x1B\x03\x16c\x95\xD8\x9BA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0BxW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0B\x9F\x91\x90\x81\x01\x90a\x13\tV[`@Q` \x01a\x0B\xAF\x91\x90a\x13\xD3V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14\x90Pa\x0B\xD3\x81\x83\x85a\x10pV[`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x14\x93PPPP\x91\x90PV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x0C\x15Wa\x0C\x15a\x12\xBBV[\x14a\x0C3W`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c#\xB8r\xDD\x90a\x0Cc\x903\x900\x90\x87\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\x7FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xA3\x91\x90a\x14SV[P__a\x0C\xB0\x85\x84a\x10LV[`@Qc@\xC1\x0F\x19`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R\x91\x93P\x91P`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c@\xC1\x0F\x19\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0C\xFAW__\xFD[PZ\xF1\x15\x80\x15a\r\x0CW=__>=_\xFD[PP`@Qc@\xC1\x0F\x19`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc@\xC1\x0F\x19\x91P`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\rUW__\xFD[PZ\xF1\x15\x80\x15a\rgW=__>=_\xFD[PPPP\x82\x85`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8F\xB8\xA3)\xBCh\x855h\xE0\xDD'\xC6\xAE\xE2\xE3a\xA1\xF0x\x92\xCFe\xABI\xCC/0\xCD!\xC3\xC5\x87\x86\x86`@Qa\x08\xD2\x93\x92\x91\x90\x92\x83R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[__\x82\x84\x84`@Qa\r\xDE\x90a\x11\xBBV[`\x80\x80\x82R`\x03\x90\x82\x01\x81\x90RbYes`\xE8\x1B`\xA0\x83\x01R`\xC0` \x83\x01\x81\x90R\x82\x01RbYES`\xE8\x1B`\xE0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`@\x83\x01R``\x82\x01Ra\x01\0\x01\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0EEW=__>=_\xFD[P\x91P\x82\x84\x84`@Qa\x0EW\x90a\x11\xBBV[`\x80\x80\x82R`\x02\x90\x82\x01\x81\x90RaNo`\xF0\x1B`\xA0\x83\x01R`\xC0` \x83\x01\x81\x90R\x82\x01RaNO`\xF0\x1B`\xE0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`@\x83\x01R``\x82\x01Ra\x01\0\x01\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\xBCW=__>=_\xFD[P`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x83\x81\x16` \x83\x01R\x82Q\x93\x94P\x87\x16\x92\x86\x92\x7F\x9EC\x1C\xAE\xF5u>>\x93\x96S\xFC\x05l\x91\x07%\x98\0)\xB3e=\xB5\xA3k\xEB\xCAq\xD6\xBC,\x92\x82\x90\x03\x01\x90\xA3\x92P\x92\x90PV[`@\x80Q` \x81\x01\x85\x90Rc\xFF\xFF\xFF\xFF\x84\x16\x91\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x82\x16``\x82\x01R_\x90`\x80\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P__\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x0FyWa\x0Fya\x12\xBBV[\x14a\x0F\x97W`@Qc7\xA5\xBD\x9B`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81\x81R`\x01` \x81\x81R`@\x80\x84 \x80T`\xFF\x19\x16\x84\x17\x90U\x80Q``\x81\x01\x82Rc\xFF\xFF\xFF\xFF\x88\x81\x16\x80\x83R`\x01`\x01`\xA0\x1B\x03\x89\x81\x16\x84\x87\x01\x81\x81R\x85\x87\x01\x8E\x81R\x8B\x8BR\x8A\x89R\x99\x87\x90 \x95Q\x86T\x91Q\x95\x16`\x01`\x01`\xC0\x1B\x03\x19\x90\x91\x16\x17d\x01\0\0\0\0\x94\x90\x92\x16\x93\x90\x93\x02\x17\x83U\x95Q\x91\x90\x94\x01U\x80Q\x93\x84RQ\x91\x92\x87\x92\x85\x92\x7F\tN\xBAi\xD7\xCA\x9D\xFA\xFA4\xC8\x96\x06\x7F\xC8\xE1\x93\x95\xA6\x10\xE4}\xEB\x8B%\xB2\x1B\x87\xBE\xC3*4\x92\x82\x90\x03\x01\x90\xA4PPPPV[__a\x10Z`\x01\x85\x85a\x10pV[\x91Pa\x10g_\x85\x85a\x10pV[\x90P\x92P\x92\x90PV[__`@Q\x80` \x01a\x10\x82\x90a\x11\xBBV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@R\x85a\x10\xBAW`@Q\x80`@\x01`@R\x80`\x02\x81R` \x01aNo`\xF0\x1B\x81RPa\x10\xD7V[`@Q\x80`@\x01`@R\x80`\x03\x81R` \x01bYes`\xE8\x1B\x81RP[\x86a\x10\xFCW`@Q\x80`@\x01`@R\x80`\x02\x81R` \x01aNO`\xF0\x1B\x81RPa\x11\x19V[`@Q\x80`@\x01`@R\x80`\x03\x81R` \x01bYES`\xE8\x1B\x81RP[\x86\x86`@Q` \x01a\x11.\x94\x93\x92\x91\x90a\x14\xA0V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x11L\x92\x91` \x01a\x14\xE1V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 `\x01`\x01`\xF8\x1B\x03\x19\x82\x85\x01R0``\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`!\x85\x01R`5\x84\x01\x96\x90\x96R`U\x80\x84\x01\x96\x90\x96R\x81Q\x80\x84\x03\x90\x96\x01\x86R`u\x90\x92\x01\x90R\x83Q\x93\x01\x92\x90\x92 \x94\x93PPPPV[a\x10G\x80a\x14\xFE\x839\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x11\xDCW__\xFD[PV[__`@\x83\x85\x03\x12\x15a\x11\xF0W__\xFD[\x825a\x11\xFB\x81a\x11\xC8V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a\x12\x1BW__\xFD[\x835a\x12&\x81a\x11\xC8V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x12KW__\xFD[P5\x91\x90PV[_` \x82\x84\x03\x12\x15a\x12bW__\xFD[\x815a\x12m\x81a\x11\xC8V[\x93\x92PPPV[___``\x84\x86\x03\x12\x15a\x12\x86W__\xFD[\x835\x92P` \x84\x015c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\xA0W__\xFD[\x91P`@\x84\x015a\x12\xB0\x81a\x11\xC8V[\x80\x91PP\x92P\x92P\x92V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[` \x81\x01`\x05\x83\x10a\x12\xEFWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x91\x90R\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\x13\x19W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13/W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x13?W__\xFD[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13YWa\x13Ya\x12\xF5V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x13\x88Wa\x13\x88a\x12\xF5V[`@R\x81\x81R\x82\x82\x01` \x01\x86\x10\x15a\x13\x9FW__\xFD[\x81` \x84\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a\x12m\x82\x84a\x13\xBCV[_` \x82\x84\x03\x12\x15a\x13\xEEW__\xFD[PQ\x91\x90PV[_` \x82\x84\x03\x12\x15a\x14\x05W__\xFD[\x81Qa\x12m\x81a\x11\xC8V[_\x82a\x14*WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x91\x90\x92\x16` \x82\x01R`@\x81\x01\x91\x90\x91R``\x01\x90V[_` \x82\x84\x03\x12\x15a\x14cW__\xFD[\x81Q\x80\x15\x15\x81\x14a\x12mW__\xFD[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[`\x80\x81R_a\x14\xB2`\x80\x83\x01\x87a\x14rV[\x82\x81\x03` \x84\x01Ra\x14\xC4\x81\x87a\x14rV[`\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16`@\x84\x01RPP``\x01R\x92\x91PPV[_a\x14\xF5a\x14\xEF\x83\x86a\x13\xBCV[\x84a\x13\xBCV[\x94\x93PPPPV\xFE`\xC0`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa\x10G8\x03\x80a\x10G\x839\x81\x01`@\x81\x90Ra\0.\x91a\x01CV[_a\09\x85\x82a\x02RV[P`\x01a\0F\x84\x82a\x02RV[P`\x01`\x01`\xA0\x1B\x03\x82\x16`\x80R`\xA0\x81\x90Ra\0b3a\0kV[PPPPa\x03\x0CV[`\x01`\x01`\xA0\x1B\x03\x16c\x8Bx\xC6\xD8\x19\x81\x90U\x80_\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x81\x80\xA3PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\0\xC9W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\0\xE2Wa\0\xE2a\0\xA6V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x01\x10Wa\x01\x10a\0\xA6V[`@R\x81\x81R\x83\x82\x01` \x01\x85\x10\x15a\x01'W__\xFD[\x81` \x85\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x01VW__\xFD[\x84Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01kW__\xFD[a\x01w\x87\x82\x88\x01a\0\xBAV[` \x87\x01Q\x90\x95P\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01\x94W__\xFD[a\x01\xA0\x87\x82\x88\x01a\0\xBAV[`@\x87\x01Q\x90\x94P\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x01\xBEW__\xFD[``\x95\x90\x95\x01Q\x93\x96\x92\x95PPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x01\xE2W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x02\0WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x02MW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x02+WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x02JW_\x81U`\x01\x01a\x027V[PP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02kWa\x02ka\0\xA6V[a\x02\x7F\x81a\x02y\x84Ta\x01\xCEV[\x84a\x02\x06V[` `\x1F\x82\x11`\x01\x81\x14a\x02\xB1W_\x83\x15a\x02\x9AWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x02JV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x02\xE0W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x02\xC0V[P\x84\x82\x10\x15a\x02\xFDW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[`\x80Q`\xA0Qa\r\x1Aa\x03-_9_a\x03n\x01R_a\x02G\x01Ra\r\x1A_\xF3\xFE`\x80`@R`\x046\x10a\x01<W_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xB3W\x80c\xC0GM\x0B\x11a\0mW\x80c\xC0GM\x0B\x14a\x03]W\x80c\xD5\x05\xAC\xCF\x14a\x03\x90W\x80c\xDDb\xED>\x14a\x03\xAFW\x80c\xF0N(>\x14a\x03\xCEW\x80c\xF2\xFD\xE3\x8B\x14a\x03\xE1W\x80c\xFE\xE8\x1C\xF4\x14a\x03\xF4W__\xFD[\x80cqP\x18\xA6\x14a\x02\xBAW\x80c~\xCE\xBE\0\x14a\x02\xC2W\x80c\x8D\xA5\xCB[\x14a\x02\xF3W\x80c\x95\xD8\x9BA\x14a\x03\x0BW\x80c\x9D\xC2\x9F\xAC\x14a\x03\x1FW\x80c\xA9\x05\x9C\xBB\x14a\x03>W__\xFD[\x80c1<\xE5g\x11a\x01\x04W\x80c1<\xE5g\x14a\x01\xE8W\x80c6D\xE5\x15\x14a\x02\x03W\x80c@\xC1\x0F\x19\x14a\x02\x17W\x80cH\0\xD9\x7F\x14a\x026W\x80cT\xD1\xF1=\x14a\x02\x81W\x80cp\xA0\x821\x14a\x02\x89W__\xFD[\x80c\x06\xFD\xDE\x03\x14a\x01@W\x80c\t^\xA7\xB3\x14a\x01jW\x80c\x18\x16\r\xDD\x14a\x01\x99W\x80c#\xB8r\xDD\x14a\x01\xBFW\x80c%i)b\x14a\x01\xDEW[__\xFD[4\x80\x15a\x01KW__\xFD[Pa\x01Ta\x04%V[`@Qa\x01a\x91\x90a\x0B\x1CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01uW__\xFD[Pa\x01\x89a\x01\x846`\x04a\x0BlV[a\x04\xB4V[`@Q\x90\x15\x15\x81R` \x01a\x01aV[4\x80\x15a\x01\xA4W__\xFD[Ph\x054\\\xDFw\xEBh\xF4LT[`@Q\x90\x81R` \x01a\x01aV[4\x80\x15a\x01\xCAW__\xFD[Pa\x01\x89a\x01\xD96`\x04a\x0B\x94V[a\x054V[a\x01\xE6a\x05\xF0V[\0[4\x80\x15a\x01\xF3W__\xFD[P`@Q`\x12\x81R` \x01a\x01aV[4\x80\x15a\x02\x0EW__\xFD[Pa\x01\xB1a\x06=V[4\x80\x15a\x02\"W__\xFD[Pa\x01\xE6a\x0216`\x04a\x0BlV[a\x06\xB9V[4\x80\x15a\x02AW__\xFD[Pa\x02i\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01aV[a\x01\xE6a\x06\xCFV[4\x80\x15a\x02\x94W__\xFD[Pa\x01\xB1a\x02\xA36`\x04a\x0B\xCEV[c\x87\xA2\x11\xA2`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[a\x01\xE6a\x07\x08V[4\x80\x15a\x02\xCDW__\xFD[Pa\x01\xB1a\x02\xDC6`\x04a\x0B\xCEV[c87u\x08`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[4\x80\x15a\x02\xFEW__\xFD[Pc\x8Bx\xC6\xD8\x19Ta\x02iV[4\x80\x15a\x03\x16W__\xFD[Pa\x01Ta\x07\x1BV[4\x80\x15a\x03*W__\xFD[Pa\x01\xE6a\x0396`\x04a\x0BlV[a\x07*V[4\x80\x15a\x03IW__\xFD[Pa\x01\x89a\x03X6`\x04a\x0BlV[a\x07<V[4\x80\x15a\x03hW__\xFD[Pa\x01\xB1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x03\x9BW__\xFD[Pa\x01\xE6a\x03\xAA6`\x04a\x0B\xEEV[a\x07\xA0V[4\x80\x15a\x03\xBAW__\xFD[Pa\x01\xB1a\x03\xC96`\x04a\x0C[V[a\tTV[a\x01\xE6a\x03\xDC6`\x04a\x0B\xCEV[a\t\x98V[a\x01\xE6a\x03\xEF6`\x04a\x0B\xCEV[a\t\xD5V[4\x80\x15a\x03\xFFW__\xFD[Pa\x01\xB1a\x04\x0E6`\x04a\x0B\xCEV[c8\x9Au\xE1`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[``_\x80Ta\x043\x90a\x0C\x8CV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x04_\x90a\x0C\x8CV[\x80\x15a\x04\xAAW\x80`\x1F\x10a\x04\x81Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x04\xAAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x04\x8DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_`\x01`\x01`\xA0\x1B\x03\x83\x16n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3\x18\x82\x19\x15\x17a\x04\xE5Wc?hS\x9A_R`\x04`\x1C\xFD[\x82` Rc\x7F^\x9F `\x0CR3_R\x81`4`\x0C U\x81_R`,Q``\x1C3\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%` _\xA3P`\x01[\x92\x91PPV[_\x83``\x1Bn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA33\x14a\x05\x89W3` Rc\x7F^\x9F \x81\x17`\x0CR`4`\x0C \x80T\x80\x19\x15a\x05\x86W\x80\x85\x11\x15a\x05\x80Wc\x13\xBE%+_R`\x04`\x1C\xFD[\x84\x81\x03\x82U[PP[c\x87\xA2\x11\xA2\x81\x17`\x0CR` `\x0C \x80T\x80\x85\x11\x15a\x05\xAFWc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x84\x81\x03\x82UPP\x83_R` `\x0C \x83\x81T\x01\x81UP\x82` R`\x0CQ``\x1C\x81``\x1C_Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3PP`\x01\x93\x92PPPV[_b\x02\xA3\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16B\x01\x90Pc8\x9Au\xE1`\x0CR3_R\x80` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D__\xA2PV[_\x80a\x06Ga\x04%V[\x80Q\x90` \x01 \x90P`@\x80Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R` \x81\x01\x92\x90\x92R\x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6\x90\x82\x01RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 \x91\x90PV[a\x06\xC1a\t\xFBV[a\x06\xCB\x82\x82a\n\x15V[PPV[c8\x9Au\xE1`\x0CR3_R_` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92__\xA2V[a\x07\x10a\t\xFBV[a\x07\x19_a\n~V[V[```\x01\x80Ta\x043\x90a\x0C\x8CV[a\x072a\t\xFBV[a\x06\xCB\x82\x82a\n\xBBV[_c\x87\xA2\x11\xA2`\x0CR3_R` `\x0C \x80T\x80\x84\x11\x15a\x07dWc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x83\x81\x03\x82UPP\x82_R` `\x0C \x82\x81T\x01\x81UP\x81` R`\x0CQ``\x1C3_Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3P`\x01\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x86\x16n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3\x18\x85\x19\x15\x17a\x07\xD0Wc?hS\x9A_R`\x04`\x1C\xFD[_a\x07\xD9a\x04%V[\x80Q\x90` \x01 \x90P\x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6B\x86\x10\x15a\x08\x18Wc\x1A\x15\xA3\xCC_R`\x04`\x1C\xFD[`@Q\x89``\x1B``\x1C\x99P\x88``\x1B``\x1C\x98Pe87u\x08\x19\x01`\x0ER\x89_R` `\x0C \x80T\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x83R\x84` \x84\x01R\x83`@\x84\x01RF``\x84\x01R0`\x80\x84\x01R`\xA0\x83 `.R\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x83R\x8B` \x84\x01R\x8A`@\x84\x01R\x89``\x84\x01R\x80`\x80\x84\x01R\x88`\xA0\x84\x01R`\xC0\x83 `NR`B`, _R\x87`\xFF\x16` R\x86`@R\x85``R` \x80`\x80_`\x01Z\xFA\x8C=Q\x14a\t\0Wc\xDD\xAF\xBA\xEF_R`\x04`\x1C\xFD[\x01\x90Uc\x03\xFA\xF4\xF9`\xA5\x1B\x89\x17`@R`4`, \x88\x90U\x88\x8A\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%` ``\x85\x01\xA3`@RPP_``RPPPPPPPV[_n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA2\x19`\x01`\x01`\xA0\x1B\x03\x83\x16\x01a\t}WP_\x19a\x05.V[P` Rc\x7F^\x9F `\x0C\x90\x81R_\x91\x90\x91R`4\x90 T\x90V[a\t\xA0a\t\xFBV[c8\x9Au\xE1`\x0CR\x80_R` `\x0C \x80TB\x11\x15a\t\xC6Wco^\x88\x18_R`\x04`\x1C\xFD[_\x90Ua\t\xD2\x81a\n~V[PV[a\t\xDDa\t\xFBV[\x80``\x1Ba\t\xF2WctH\xFB\xAE_R`\x04`\x1C\xFD[a\t\xD2\x81a\n~V[c\x8Bx\xC6\xD8\x19T3\x14a\x07\x19Wc\x82\xB4)\0_R`\x04`\x1C\xFD[h\x054\\\xDFw\xEBh\xF4LT\x81\x81\x01\x81\x81\x10\x15a\n8Wc\xE5\xCF\xE9W_R`\x04`\x1C\xFD[\x80h\x054\\\xDFw\xEBh\xF4LUPPc\x87\xA2\x11\xA2`\x0CR\x81_R` `\x0C \x81\x81T\x01\x81UP\x80` R`\x0CQ``\x1C__Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3PPV[c\x8Bx\xC6\xD8\x19\x80T`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x82\x90\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3UV[c\x87\xA2\x11\xA2`\x0CR\x81_R` `\x0C \x80T\x80\x83\x11\x15a\n\xE2Wc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x82\x90\x03\x90Uh\x054\\\xDFw\xEBh\xF4L\x80T\x82\x90\x03\x90U_\x81\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16_Q` a\x0C\xC5_9_Q\x90_R` \x83\xA3PPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0BgW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a\x0B}W__\xFD[a\x0B\x86\x83a\x0BQV[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a\x0B\xA6W__\xFD[a\x0B\xAF\x84a\x0BQV[\x92Pa\x0B\xBD` \x85\x01a\x0BQV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_` \x82\x84\x03\x12\x15a\x0B\xDEW__\xFD[a\x0B\xE7\x82a\x0BQV[\x93\x92PPPV[_______`\xE0\x88\x8A\x03\x12\x15a\x0C\x04W__\xFD[a\x0C\r\x88a\x0BQV[\x96Pa\x0C\x1B` \x89\x01a\x0BQV[\x95P`@\x88\x015\x94P``\x88\x015\x93P`\x80\x88\x015`\xFF\x81\x16\x81\x14a\x0C>W__\xFD[\x96\x99\x95\x98P\x93\x96\x92\x95\x94`\xA0\x84\x015\x94P`\xC0\x90\x93\x015\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x0ClW__\xFD[a\x0Cu\x83a\x0BQV[\x91Pa\x0C\x83` \x84\x01a\x0BQV[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0C\xA0W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x0C\xBEWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV\xFE\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\xA2dipfsX\"\x12 \xF2U\x8A\xD4F\x0C\xA0\x0E\xBE\xBA\xB8\xD0#r\xDDk\x02\x7F\x19\xDE{\xD9\xD72\xADt\xC5\xCF$c_EdsolcC\0\x08\x1E\x003\xA2dipfsX\"\x12 \x91\x9D\xE7\xB4Y\r\xF5k\xC1\x1A\xEB0O\xA2\x9D{D\x14_5\x084\x1D\xC0\xA2\x0C\x84\xEE\xAB5\x8D\x15dsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b506004361061009b575f3560e01c80639ba730a9116100635780639ba730a91461017a578063a3def9231461018d578063c2a33c1d146101c0578063d4b06fb8146101d3578063e973955014610202575f5ffd5b80631e9a69501461009f57806341055a76146100c55780635c23bdf5146100da5780637183d24a146100ed5780637564912b14610110575b5f5ffd5b6100b26100ad3660046111df565b610215565b6040519081526020015b60405180910390f35b6100d86100d3366004611209565b61062a565b005b6100d86100e836600461123b565b6108e1565b6101006100fb366004611252565b610a46565b60405190151581526020016100bc565b61015061011e36600461123b565b5f602081905290815260409020805460019091015463ffffffff82169164010000000090046001600160a01b03169083565b6040805163ffffffff90941684526001600160a01b039092166020840152908201526060016100bc565b6100d8610188366004611209565b610bf1565b6101a061019b3660046111df565b610dcd565b604080516001600160a01b039384168152929091166020830152016100bc565b6100d86101ce366004611274565b610f0f565b6101f56101e136600461123b565b60016020525f908152604090205460ff1681565b6040516100bc91906112cf565b6101a06102103660046111df565b61104c565b5f5f604051602001610230906259455360e81b815260030190565b60405160208183030381529060405280519060200120846001600160a01b03166395d89b416040518163ffffffff1660e01b81526004015f60405180830381865afa158015610281573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102a89190810190611309565b6040516020016102b891906113d3565b604051602081830303815290604052805190602001201490505f846001600160a01b031663c0474d0b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061033291906113de565b90505f856001600160a01b0316634800d97f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610371573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061039591906113f5565b90506103a2838284611070565b6001600160a01b0316866001600160a01b0316146103d3576040516340fe50fd60e01b815260040160405180910390fd5b60025f8381526001602052604090205460ff1660048111156103f7576103f76112bb565b1480156104015750825b1561040e5784935061049e565b60035f8381526001602052604090205460ff166004811115610432576104326112bb565b14801561043d575082155b1561044a5784935061049e565b60045f8381526001602052604090205460ff16600481111561046e5761046e6112bb565b036104855761047e600286611410565b935061049e565b604051637256f64560e11b815260040160405180910390fd5b6040516323b872dd60e01b81526001600160a01b038716906323b872dd906104ce90339030908a9060040161142f565b6020604051808303815f875af11580156104ea573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061050e9190611453565b50604051632770a7eb60e21b8152306004820152602481018690526001600160a01b03871690639dc29fac906044015f604051808303815f87803b158015610554575f5ffd5b505af1158015610566573d5f5f3e3d5ffd5b505060405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038416925063a9059cbb91506044016020604051808303815f875af11580156105b4573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105d89190611453565b50604080518681526020810186905283916001600160a01b0389169133917fae1d804a86b6ba2a7725d9824d4ccb4e7f9a55e7a1bf4379c26692ce5ad00665910160405180910390a450505092915050565b60015f8281526001602052604090205460ff16600481111561064e5761064e6112bb565b1461066c5760405163239dd4ad60e11b815260040160405180910390fd5b5f5f610678858461104c565b6040516323b872dd60e01b815291935091506001600160a01b038316906323b872dd906106ad9033903090899060040161142f565b6020604051808303815f875af11580156106c9573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106ed9190611453565b506040516323b872dd60e01b81526001600160a01b038216906323b872dd9061071e9033903090899060040161142f565b6020604051808303815f875af115801561073a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061075e9190611453565b50604051632770a7eb60e21b8152306004820152602481018590526001600160a01b03831690639dc29fac906044015f604051808303815f87803b1580156107a4575f5ffd5b505af11580156107b6573d5f5f3e3d5ffd5b5050604051632770a7eb60e21b8152306004820152602481018790526001600160a01b0384169250639dc29fac91506044015f604051808303815f87803b1580156107ff575f5ffd5b505af1158015610811573d5f5f3e3d5ffd5b505060405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038816925063a9059cbb91506044016020604051808303815f875af115801561085f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108839190611453565b50604080518581526001600160a01b03848116602083015283811692820192909252849187169033907f9a853bfbdd6034e0e7553bb8ec7789b2603dcccb5759cf390a7a601c0b6da003906060015b60405180910390a45050505050565b60015f8281526001602052604090205460ff166004811115610905576109056112bb565b146109235760405163239dd4ad60e11b815260040160405180910390fd5b5f8181526020819052604081205463ffffffff164210610945575060046109d8565b5f828152602081905260408082205490516301f46b2960e11b8152600481018590526401000000009091046001600160a01b0316906303e8d652906024016020604051808303815f875af115801561099f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109c39190611453565b9050806109d15760036109d4565b60025b9150505b5f8281526001602081905260409091208054839260ff1990911690836004811115610a0557610a056112bb565b0217905550817ff34984473148051bc1bdf1be6ecc462d7b228d591058a8a27977b84770b738b982604051610a3a91906112cf565b60405180910390a25050565b5f5f826001600160a01b031663c0474d0b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a84573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610aa891906113de565b90505f836001600160a01b0316634800d97f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae7573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b0b91906113f5565b90505f604051602001610b27906259455360e81b815260030190565b60405160208183030381529060405280519060200120856001600160a01b03166395d89b416040518163ffffffff1660e01b81526004015f60405180830381865afa158015610b78573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610b9f9190810190611309565b604051602001610baf91906113d3565b60405160208183030381529060405280519060200120149050610bd3818385611070565b6001600160a01b0316856001600160a01b0316149350505050919050565b60015f8281526001602052604090205460ff166004811115610c1557610c156112bb565b14610c335760405163239dd4ad60e11b815260040160405180910390fd5b6040516323b872dd60e01b81526001600160a01b038416906323b872dd90610c639033903090879060040161142f565b6020604051808303815f875af1158015610c7f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ca39190611453565b505f5f610cb0858461104c565b6040516340c10f1960e01b81523360048201526024810187905291935091506001600160a01b038316906340c10f19906044015f604051808303815f87803b158015610cfa575f5ffd5b505af1158015610d0c573d5f5f3e3d5ffd5b50506040516340c10f1960e01b8152336004820152602481018790526001600160a01b03841692506340c10f1991506044015f604051808303815f87803b158015610d55575f5ffd5b505af1158015610d67573d5f5f3e3d5ffd5b5050505082856001600160a01b0316336001600160a01b03167f8fb8a329bc68853568e0dd27c6aee2e361a1f07892cf65ab49cc2f30cd21c3c58786866040516108d2939291909283526001600160a01b03918216602084015216604082015260600190565b5f5f828484604051610dde906111bb565b608080825260039082018190526259657360e81b60a083015260c0602083018190528201526259455360e81b60e08201526001600160a01b0390921660408301526060820152610100018190604051809103905ff5905080158015610e45573d5f5f3e3d5ffd5b509150828484604051610e57906111bb565b60808082526002908201819052614e6f60f01b60a083015260c060208301819052820152614e4f60f01b60e08201526001600160a01b0390921660408301526060820152610100018190604051809103905ff5905080158015610ebc573d5f5f3e3d5ffd5b50604080516001600160a01b0385811682528381166020830152825193945087169286927f9e431caef5753e3e939653fc056c910725980029b3653db5a36bebca71d6bc2c928290030190a39250929050565b604080516020810185905263ffffffff8416918101919091526001600160a01b03821660608201525f9060800160408051601f19818403018152919052805160209091012090505f5f8281526001602052604090205460ff166004811115610f7957610f796112bb565b14610f97576040516337a5bd9b60e11b815260040160405180910390fd5b5f818152600160208181526040808420805460ff191684179055805160608101825263ffffffff8881168083526001600160a01b038981168487018181528587018e81528b8b528a89529987902095518654915195166001600160c01b0319909116176401000000009490921693909302178355955191909401558051938452519192879285927f094eba69d7ca9dfafa34c896067fc8e19395a610e47deb8b25b21b87bec32a34928290030190a450505050565b5f5f61105a60018585611070565b91506110675f8585611070565b90509250929050565b5f5f60405180602001611082906111bb565b601f1982820381018352601f90910116604052856110ba57604051806040016040528060028152602001614e6f60f01b8152506110d7565b6040518060400160405280600381526020016259657360e81b8152505b866110fc57604051806040016040528060028152602001614e4f60f01b815250611119565b6040518060400160405280600381526020016259455360e81b8152505b868660405160200161112e94939291906114a0565b60408051601f198184030181529082905261114c92916020016114e1565b60408051808303601f1901815282825280516020918201206001600160f81b0319828501523060601b6bffffffffffffffffffffffff19166021850152603584019690965260558084019690965281518084039096018652607590920190528351930192909220949350505050565b611047806114fe83390190565b6001600160a01b03811681146111dc575f5ffd5b50565b5f5f604083850312156111f0575f5ffd5b82356111fb816111c8565b946020939093013593505050565b5f5f5f6060848603121561121b575f5ffd5b8335611226816111c8565b95602085013595506040909401359392505050565b5f6020828403121561124b575f5ffd5b5035919050565b5f60208284031215611262575f5ffd5b813561126d816111c8565b9392505050565b5f5f5f60608486031215611286575f5ffd5b83359250602084013563ffffffff811681146112a0575f5ffd5b915060408401356112b0816111c8565b809150509250925092565b634e487b7160e01b5f52602160045260245ffd5b60208101600583106112ef57634e487b7160e01b5f52602160045260245ffd5b91905290565b634e487b7160e01b5f52604160045260245ffd5b5f60208284031215611319575f5ffd5b815167ffffffffffffffff81111561132f575f5ffd5b8201601f8101841361133f575f5ffd5b805167ffffffffffffffff811115611359576113596112f5565b604051601f8201601f19908116603f0116810167ffffffffffffffff81118282101715611388576113886112f5565b60405281815282820160200186101561139f575f5ffd5b8160208401602083015e5f91810160200191909152949350505050565b5f81518060208401855e5f93019283525090919050565b5f61126d82846113bc565b5f602082840312156113ee575f5ffd5b5051919050565b5f60208284031215611405575f5ffd5b815161126d816111c8565b5f8261142a57634e487b7160e01b5f52601260045260245ffd5b500490565b6001600160a01b039384168152919092166020820152604081019190915260600190565b5f60208284031215611463575f5ffd5b8151801515811461126d575f5ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b608081525f6114b26080830187611472565b82810360208401526114c48187611472565b6001600160a01b0395909516604084015250506060015292915050565b5f6114f56114ef83866113bc565b846113bc565b94935050505056fe60c060405234801561000f575f5ffd5b5060405161104738038061104783398101604081905261002e91610143565b5f6100398582610252565b5060016100468482610252565b506001600160a01b03821660805260a08190526100623361006b565b5050505061030c565b6001600160a01b0316638b78c6d819819055805f7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a350565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126100c9575f5ffd5b81516001600160401b038111156100e2576100e26100a6565b604051601f8201601f19908116603f011681016001600160401b0381118282101715610110576101106100a6565b604052818152838201602001851015610127575f5ffd5b8160208501602083015e5f918101602001919091529392505050565b5f5f5f5f60808587031215610156575f5ffd5b84516001600160401b0381111561016b575f5ffd5b610177878288016100ba565b602087015190955090506001600160401b03811115610194575f5ffd5b6101a0878288016100ba565b604087015190945090506001600160a01b03811681146101be575f5ffd5b6060959095015193969295505050565b600181811c908216806101e257607f821691505b60208210810361020057634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561024d57805f5260205f20601f840160051c8101602085101561022b5750805b601f840160051c820191505b8181101561024a575f8155600101610237565b50505b505050565b81516001600160401b0381111561026b5761026b6100a6565b61027f8161027984546101ce565b84610206565b6020601f8211600181146102b1575f831561029a5750848201515b5f19600385901b1c1916600184901b17845561024a565b5f84815260208120601f198516915b828110156102e057878501518255602094850194600190920191016102c0565b50848210156102fd57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b60805160a051610d1a61032d5f395f61036e01525f6102470152610d1a5ff3fe60806040526004361061013c575f3560e01c8063715018a6116100b3578063c0474d0b1161006d578063c0474d0b1461035d578063d505accf14610390578063dd62ed3e146103af578063f04e283e146103ce578063f2fde38b146103e1578063fee81cf4146103f4575f5ffd5b8063715018a6146102ba5780637ecebe00146102c25780638da5cb5b146102f357806395d89b411461030b5780639dc29fac1461031f578063a9059cbb1461033e575f5ffd5b8063313ce56711610104578063313ce567146101e85780633644e5151461020357806340c10f19146102175780634800d97f1461023657806354d1f13d1461028157806370a0823114610289575f5ffd5b806306fdde0314610140578063095ea7b31461016a57806318160ddd1461019957806323b872dd146101bf57806325692962146101de575b5f5ffd5b34801561014b575f5ffd5b50610154610425565b6040516101619190610b1c565b60405180910390f35b348015610175575f5ffd5b50610189610184366004610b6c565b6104b4565b6040519015158152602001610161565b3480156101a4575f5ffd5b506805345cdf77eb68f44c545b604051908152602001610161565b3480156101ca575f5ffd5b506101896101d9366004610b94565b610534565b6101e66105f0565b005b3480156101f3575f5ffd5b5060405160128152602001610161565b34801561020e575f5ffd5b506101b161063d565b348015610222575f5ffd5b506101e6610231366004610b6c565b6106b9565b348015610241575f5ffd5b506102697f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610161565b6101e66106cf565b348015610294575f5ffd5b506101b16102a3366004610bce565b6387a211a2600c9081525f91909152602090205490565b6101e6610708565b3480156102cd575f5ffd5b506101b16102dc366004610bce565b6338377508600c9081525f91909152602090205490565b3480156102fe575f5ffd5b50638b78c6d81954610269565b348015610316575f5ffd5b5061015461071b565b34801561032a575f5ffd5b506101e6610339366004610b6c565b61072a565b348015610349575f5ffd5b50610189610358366004610b6c565b61073c565b348015610368575f5ffd5b506101b17f000000000000000000000000000000000000000000000000000000000000000081565b34801561039b575f5ffd5b506101e66103aa366004610bee565b6107a0565b3480156103ba575f5ffd5b506101b16103c9366004610c5b565b610954565b6101e66103dc366004610bce565b610998565b6101e66103ef366004610bce565b6109d5565b3480156103ff575f5ffd5b506101b161040e366004610bce565b63389a75e1600c9081525f91909152602090205490565b60605f805461043390610c8c565b80601f016020809104026020016040519081016040528092919081815260200182805461045f90610c8c565b80156104aa5780601f10610481576101008083540402835291602001916104aa565b820191905f5260205f20905b81548152906001019060200180831161048d57829003601f168201915b5050505050905090565b5f6001600160a01b0383166e22d473030f116ddee9f6b43ac78ba318821915176104e557633f68539a5f526004601cfd5b82602052637f5e9f20600c52335f52816034600c2055815f52602c5160601c337f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560205fa35060015b92915050565b5f8360601b6e22d473030f116ddee9f6b43ac78ba333146105895733602052637f5e9f208117600c526034600c2080548019156105865780851115610580576313be252b5f526004601cfd5b84810382555b50505b6387a211a28117600c526020600c208054808511156105af5763f4d678b85f526004601cfd5b84810382555050835f526020600c208381540181555082602052600c5160601c8160601c5f516020610cc55f395f51905f52602080a3505060019392505050565b5f6202a30067ffffffffffffffff164201905063389a75e1600c52335f52806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d5f5fa250565b5f80610647610425565b805190602001209050604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f815260208101929092527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc69082015246606082015230608082015260a09020919050565b6106c16109fb565b6106cb8282610a15565b5050565b63389a75e1600c52335f525f6020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c925f5fa2565b6107106109fb565b6107195f610a7e565b565b60606001805461043390610c8c565b6107326109fb565b6106cb8282610abb565b5f6387a211a2600c52335f526020600c208054808411156107645763f4d678b85f526004601cfd5b83810382555050825f526020600c208281540181555081602052600c5160601c335f516020610cc55f395f51905f52602080a350600192915050565b6001600160a01b0386166e22d473030f116ddee9f6b43ac78ba318851915176107d057633f68539a5f526004601cfd5b5f6107d9610425565b8051906020012090507fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc64286101561081857631a15a3cc5f526004601cfd5b6040518960601b60601c99508860601b60601c985065383775081901600e52895f526020600c2080547f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f835284602084015283604084015246606084015230608084015260a08320602e527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c983528b60208401528a60408401528960608401528060808401528860a084015260c08320604e526042602c205f528760ff16602052866040528560605260208060805f60015afa8c3d51146109005763ddafbaef5f526004601cfd5b0190556303faf4f960a51b89176040526034602c20889055888a7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602060608501a360405250505f60605250505050505050565b5f6e22d473030f116ddee9f6b43ac78ba2196001600160a01b0383160161097d57505f1961052e565b50602052637f5e9f20600c9081525f91909152603490205490565b6109a06109fb565b63389a75e1600c52805f526020600c2080544211156109c657636f5e88185f526004601cfd5b5f90556109d281610a7e565b50565b6109dd6109fb565b8060601b6109f257637448fbae5f526004601cfd5b6109d281610a7e565b638b78c6d819543314610719576382b429005f526004601cfd5b6805345cdf77eb68f44c5481810181811015610a385763e5cfe9575f526004601cfd5b806805345cdf77eb68f44c5550506387a211a2600c52815f526020600c208181540181555080602052600c5160601c5f5f516020610cc55f395f51905f52602080a35050565b638b78c6d81980546001600160a01b039092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a355565b6387a211a2600c52815f526020600c20805480831115610ae25763f4d678b85f526004601cfd5b82900390556805345cdf77eb68f44c805482900390555f8181526001600160a01b0383165f516020610cc55f395f51905f52602083a35050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b0381168114610b67575f5ffd5b919050565b5f5f60408385031215610b7d575f5ffd5b610b8683610b51565b946020939093013593505050565b5f5f5f60608486031215610ba6575f5ffd5b610baf84610b51565b9250610bbd60208501610b51565b929592945050506040919091013590565b5f60208284031215610bde575f5ffd5b610be782610b51565b9392505050565b5f5f5f5f5f5f5f60e0888a031215610c04575f5ffd5b610c0d88610b51565b9650610c1b60208901610b51565b95506040880135945060608801359350608088013560ff81168114610c3e575f5ffd5b9699959850939692959460a0840135945060c09093013592915050565b5f5f60408385031215610c6c575f5ffd5b610c7583610b51565b9150610c8360208401610b51565b90509250929050565b600181811c90821680610ca057607f821691505b602082108103610cbe57634e487b7160e01b5f52602260045260245ffd5b5091905056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220f2558ad4460ca00ebebab8d02372dd6b027f19de7bd9d732ad74c5cf24635f4564736f6c634300081e0033a2646970667358221220919de7b4590df56bc11aeb304fa29d7b44145f3508341dc0a20c84eeab358d1564736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x9BW_5`\xE0\x1C\x80c\x9B\xA70\xA9\x11a\0cW\x80c\x9B\xA70\xA9\x14a\x01zW\x80c\xA3\xDE\xF9#\x14a\x01\x8DW\x80c\xC2\xA3<\x1D\x14a\x01\xC0W\x80c\xD4\xB0o\xB8\x14a\x01\xD3W\x80c\xE9s\x95P\x14a\x02\x02W__\xFD[\x80c\x1E\x9AiP\x14a\0\x9FW\x80cA\x05Zv\x14a\0\xC5W\x80c\\#\xBD\xF5\x14a\0\xDAW\x80cq\x83\xD2J\x14a\0\xEDW\x80cud\x91+\x14a\x01\x10W[__\xFD[a\0\xB2a\0\xAD6`\x04a\x11\xDFV[a\x02\x15V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xD8a\0\xD36`\x04a\x12\tV[a\x06*V[\0[a\0\xD8a\0\xE86`\x04a\x12;V[a\x08\xE1V[a\x01\0a\0\xFB6`\x04a\x12RV[a\nFV[`@Q\x90\x15\x15\x81R` \x01a\0\xBCV[a\x01Pa\x01\x1E6`\x04a\x12;V[_` \x81\x90R\x90\x81R`@\x90 \x80T`\x01\x90\x91\x01Tc\xFF\xFF\xFF\xFF\x82\x16\x91d\x01\0\0\0\0\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90\x83V[`@\x80Qc\xFF\xFF\xFF\xFF\x90\x94\x16\x84R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16` \x84\x01R\x90\x82\x01R``\x01a\0\xBCV[a\0\xD8a\x01\x886`\x04a\x12\tV[a\x0B\xF1V[a\x01\xA0a\x01\x9B6`\x04a\x11\xDFV[a\r\xCDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\0\xBCV[a\0\xD8a\x01\xCE6`\x04a\x12tV[a\x0F\x0FV[a\x01\xF5a\x01\xE16`\x04a\x12;V[`\x01` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[`@Qa\0\xBC\x91\x90a\x12\xCFV[a\x01\xA0a\x02\x106`\x04a\x11\xDFV[a\x10LV[__`@Q` \x01a\x020\x90bYES`\xE8\x1B\x81R`\x03\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x84`\x01`\x01`\xA0\x1B\x03\x16c\x95\xD8\x9BA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\x81W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x02\xA8\x91\x90\x81\x01\x90a\x13\tV[`@Q` \x01a\x02\xB8\x91\x90a\x13\xD3V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14\x90P_\x84`\x01`\x01`\xA0\x1B\x03\x16c\xC0GM\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\x0EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x032\x91\x90a\x13\xDEV[\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16cH\0\xD9\x7F`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03qW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\x95\x91\x90a\x13\xF5V[\x90Pa\x03\xA2\x83\x82\x84a\x10pV[`\x01`\x01`\xA0\x1B\x03\x16\x86`\x01`\x01`\xA0\x1B\x03\x16\x14a\x03\xD3W`@Qc@\xFEP\xFD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x03\xF7Wa\x03\xF7a\x12\xBBV[\x14\x80\x15a\x04\x01WP\x82[\x15a\x04\x0EW\x84\x93Pa\x04\x9EV[`\x03_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x042Wa\x042a\x12\xBBV[\x14\x80\x15a\x04=WP\x82\x15[\x15a\x04JW\x84\x93Pa\x04\x9EV[`\x04_\x83\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x04nWa\x04na\x12\xBBV[\x03a\x04\x85Wa\x04~`\x02\x86a\x14\x10V[\x93Pa\x04\x9EV[`@QcrV\xF6E`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c#\xB8r\xDD\x90a\x04\xCE\x903\x900\x90\x8A\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x04\xEAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\x0E\x91\x90a\x14SV[P`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x86\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\x9D\xC2\x9F\xAC\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x05TW__\xFD[PZ\xF1\x15\x80\x15a\x05fW=__>=_\xFD[PP`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc\xA9\x05\x9C\xBB\x91P`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x05\xB4W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xD8\x91\x90a\x14SV[P`@\x80Q\x86\x81R` \x81\x01\x86\x90R\x83\x91`\x01`\x01`\xA0\x1B\x03\x89\x16\x913\x91\x7F\xAE\x1D\x80J\x86\xB6\xBA*w%\xD9\x82ML\xCBN\x7F\x9AU\xE7\xA1\xBFCy\xC2f\x92\xCEZ\xD0\x06e\x91\x01`@Q\x80\x91\x03\x90\xA4PPP\x92\x91PPV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x06NWa\x06Na\x12\xBBV[\x14a\x06lW`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__a\x06x\x85\x84a\x10LV[`@Qc#\xB8r\xDD`\xE0\x1B\x81R\x91\x93P\x91P`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c#\xB8r\xDD\x90a\x06\xAD\x903\x900\x90\x89\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x06\xC9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\xED\x91\x90a\x14SV[P`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c#\xB8r\xDD\x90a\x07\x1E\x903\x900\x90\x89\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x07:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07^\x91\x90a\x14SV[P`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x85\x90R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\x9D\xC2\x9F\xAC\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x07\xA4W__\xFD[PZ\xF1\x15\x80\x15a\x07\xB6W=__>=_\xFD[PP`@Qc'p\xA7\xEB`\xE2\x1B\x81R0`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc\x9D\xC2\x9F\xAC\x91P`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x07\xFFW__\xFD[PZ\xF1\x15\x80\x15a\x08\x11W=__>=_\xFD[PP`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x88\x16\x92Pc\xA9\x05\x9C\xBB\x91P`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x08_W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a\x14SV[P`@\x80Q\x85\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16` \x83\x01R\x83\x81\x16\x92\x82\x01\x92\x90\x92R\x84\x91\x87\x16\x903\x90\x7F\x9A\x85;\xFB\xDD`4\xE0\xE7U;\xB8\xECw\x89\xB2`=\xCC\xCBWY\xCF9\nz`\x1C\x0Bm\xA0\x03\x90``\x01[`@Q\x80\x91\x03\x90\xA4PPPPPV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\t\x05Wa\t\x05a\x12\xBBV[\x14a\t#W`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81\x81R` \x81\x90R`@\x81 Tc\xFF\xFF\xFF\xFF\x16B\x10a\tEWP`\x04a\t\xD8V[_\x82\x81R` \x81\x90R`@\x80\x82 T\x90Qc\x01\xF4k)`\xE1\x1B\x81R`\x04\x81\x01\x85\x90Rd\x01\0\0\0\0\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x03\xE8\xD6R\x90`$\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\t\x9FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xC3\x91\x90a\x14SV[\x90P\x80a\t\xD1W`\x03a\t\xD4V[`\x02[\x91PP[_\x82\x81R`\x01` \x81\x90R`@\x90\x91 \x80T\x83\x92`\xFF\x19\x90\x91\x16\x90\x83`\x04\x81\x11\x15a\n\x05Wa\n\x05a\x12\xBBV[\x02\x17\x90UP\x81\x7F\xF3I\x84G1H\x05\x1B\xC1\xBD\xF1\xBEn\xCCF-{\"\x8DY\x10X\xA8\xA2yw\xB8Gp\xB78\xB9\x82`@Qa\n:\x91\x90a\x12\xCFV[`@Q\x80\x91\x03\x90\xA2PPV[__\x82`\x01`\x01`\xA0\x1B\x03\x16c\xC0GM\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x84W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xA8\x91\x90a\x13\xDEV[\x90P_\x83`\x01`\x01`\xA0\x1B\x03\x16cH\0\xD9\x7F`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xE7W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\x0B\x91\x90a\x13\xF5V[\x90P_`@Q` \x01a\x0B'\x90bYES`\xE8\x1B\x81R`\x03\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x85`\x01`\x01`\xA0\x1B\x03\x16c\x95\xD8\x9BA`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0BxW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0B\x9F\x91\x90\x81\x01\x90a\x13\tV[`@Q` \x01a\x0B\xAF\x91\x90a\x13\xD3V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14\x90Pa\x0B\xD3\x81\x83\x85a\x10pV[`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x14\x93PPPP\x91\x90PV[`\x01_\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x0C\x15Wa\x0C\x15a\x12\xBBV[\x14a\x0C3W`@Qc#\x9D\xD4\xAD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qc#\xB8r\xDD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c#\xB8r\xDD\x90a\x0Cc\x903\x900\x90\x87\x90`\x04\x01a\x14/V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0C\x7FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xA3\x91\x90a\x14SV[P__a\x0C\xB0\x85\x84a\x10LV[`@Qc@\xC1\x0F\x19`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R\x91\x93P\x91P`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c@\xC1\x0F\x19\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0C\xFAW__\xFD[PZ\xF1\x15\x80\x15a\r\x0CW=__>=_\xFD[PP`@Qc@\xC1\x0F\x19`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x84\x16\x92Pc@\xC1\x0F\x19\x91P`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\rUW__\xFD[PZ\xF1\x15\x80\x15a\rgW=__>=_\xFD[PPPP\x82\x85`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8F\xB8\xA3)\xBCh\x855h\xE0\xDD'\xC6\xAE\xE2\xE3a\xA1\xF0x\x92\xCFe\xABI\xCC/0\xCD!\xC3\xC5\x87\x86\x86`@Qa\x08\xD2\x93\x92\x91\x90\x92\x83R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[__\x82\x84\x84`@Qa\r\xDE\x90a\x11\xBBV[`\x80\x80\x82R`\x03\x90\x82\x01\x81\x90RbYes`\xE8\x1B`\xA0\x83\x01R`\xC0` \x83\x01\x81\x90R\x82\x01RbYES`\xE8\x1B`\xE0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`@\x83\x01R``\x82\x01Ra\x01\0\x01\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0EEW=__>=_\xFD[P\x91P\x82\x84\x84`@Qa\x0EW\x90a\x11\xBBV[`\x80\x80\x82R`\x02\x90\x82\x01\x81\x90RaNo`\xF0\x1B`\xA0\x83\x01R`\xC0` \x83\x01\x81\x90R\x82\x01RaNO`\xF0\x1B`\xE0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`@\x83\x01R``\x82\x01Ra\x01\0\x01\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\xBCW=__>=_\xFD[P`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x83\x81\x16` \x83\x01R\x82Q\x93\x94P\x87\x16\x92\x86\x92\x7F\x9EC\x1C\xAE\xF5u>>\x93\x96S\xFC\x05l\x91\x07%\x98\0)\xB3e=\xB5\xA3k\xEB\xCAq\xD6\xBC,\x92\x82\x90\x03\x01\x90\xA3\x92P\x92\x90PV[`@\x80Q` \x81\x01\x85\x90Rc\xFF\xFF\xFF\xFF\x84\x16\x91\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x82\x16``\x82\x01R_\x90`\x80\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P__\x82\x81R`\x01` R`@\x90 T`\xFF\x16`\x04\x81\x11\x15a\x0FyWa\x0Fya\x12\xBBV[\x14a\x0F\x97W`@Qc7\xA5\xBD\x9B`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81\x81R`\x01` \x81\x81R`@\x80\x84 \x80T`\xFF\x19\x16\x84\x17\x90U\x80Q``\x81\x01\x82Rc\xFF\xFF\xFF\xFF\x88\x81\x16\x80\x83R`\x01`\x01`\xA0\x1B\x03\x89\x81\x16\x84\x87\x01\x81\x81R\x85\x87\x01\x8E\x81R\x8B\x8BR\x8A\x89R\x99\x87\x90 \x95Q\x86T\x91Q\x95\x16`\x01`\x01`\xC0\x1B\x03\x19\x90\x91\x16\x17d\x01\0\0\0\0\x94\x90\x92\x16\x93\x90\x93\x02\x17\x83U\x95Q\x91\x90\x94\x01U\x80Q\x93\x84RQ\x91\x92\x87\x92\x85\x92\x7F\tN\xBAi\xD7\xCA\x9D\xFA\xFA4\xC8\x96\x06\x7F\xC8\xE1\x93\x95\xA6\x10\xE4}\xEB\x8B%\xB2\x1B\x87\xBE\xC3*4\x92\x82\x90\x03\x01\x90\xA4PPPPV[__a\x10Z`\x01\x85\x85a\x10pV[\x91Pa\x10g_\x85\x85a\x10pV[\x90P\x92P\x92\x90PV[__`@Q\x80` \x01a\x10\x82\x90a\x11\xBBV[`\x1F\x19\x82\x82\x03\x81\x01\x83R`\x1F\x90\x91\x01\x16`@R\x85a\x10\xBAW`@Q\x80`@\x01`@R\x80`\x02\x81R` \x01aNo`\xF0\x1B\x81RPa\x10\xD7V[`@Q\x80`@\x01`@R\x80`\x03\x81R` \x01bYes`\xE8\x1B\x81RP[\x86a\x10\xFCW`@Q\x80`@\x01`@R\x80`\x02\x81R` \x01aNO`\xF0\x1B\x81RPa\x11\x19V[`@Q\x80`@\x01`@R\x80`\x03\x81R` \x01bYES`\xE8\x1B\x81RP[\x86\x86`@Q` \x01a\x11.\x94\x93\x92\x91\x90a\x14\xA0V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x11L\x92\x91` \x01a\x14\xE1V[`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 `\x01`\x01`\xF8\x1B\x03\x19\x82\x85\x01R0``\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`!\x85\x01R`5\x84\x01\x96\x90\x96R`U\x80\x84\x01\x96\x90\x96R\x81Q\x80\x84\x03\x90\x96\x01\x86R`u\x90\x92\x01\x90R\x83Q\x93\x01\x92\x90\x92 \x94\x93PPPPV[a\x10G\x80a\x14\xFE\x839\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x11\xDCW__\xFD[PV[__`@\x83\x85\x03\x12\x15a\x11\xF0W__\xFD[\x825a\x11\xFB\x81a\x11\xC8V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a\x12\x1BW__\xFD[\x835a\x12&\x81a\x11\xC8V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x12KW__\xFD[P5\x91\x90PV[_` \x82\x84\x03\x12\x15a\x12bW__\xFD[\x815a\x12m\x81a\x11\xC8V[\x93\x92PPPV[___``\x84\x86\x03\x12\x15a\x12\x86W__\xFD[\x835\x92P` \x84\x015c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\xA0W__\xFD[\x91P`@\x84\x015a\x12\xB0\x81a\x11\xC8V[\x80\x91PP\x92P\x92P\x92V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[` \x81\x01`\x05\x83\x10a\x12\xEFWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x91\x90R\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\x13\x19W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13/W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x13?W__\xFD[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13YWa\x13Ya\x12\xF5V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x13\x88Wa\x13\x88a\x12\xF5V[`@R\x81\x81R\x82\x82\x01` \x01\x86\x10\x15a\x13\x9FW__\xFD[\x81` \x84\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a\x12m\x82\x84a\x13\xBCV[_` \x82\x84\x03\x12\x15a\x13\xEEW__\xFD[PQ\x91\x90PV[_` \x82\x84\x03\x12\x15a\x14\x05W__\xFD[\x81Qa\x12m\x81a\x11\xC8V[_\x82a\x14*WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x91\x90\x92\x16` \x82\x01R`@\x81\x01\x91\x90\x91R``\x01\x90V[_` \x82\x84\x03\x12\x15a\x14cW__\xFD[\x81Q\x80\x15\x15\x81\x14a\x12mW__\xFD[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[`\x80\x81R_a\x14\xB2`\x80\x83\x01\x87a\x14rV[\x82\x81\x03` \x84\x01Ra\x14\xC4\x81\x87a\x14rV[`\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16`@\x84\x01RPP``\x01R\x92\x91PPV[_a\x14\xF5a\x14\xEF\x83\x86a\x13\xBCV[\x84a\x13\xBCV[\x94\x93PPPPV\xFE`\xC0`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa\x10G8\x03\x80a\x10G\x839\x81\x01`@\x81\x90Ra\0.\x91a\x01CV[_a\09\x85\x82a\x02RV[P`\x01a\0F\x84\x82a\x02RV[P`\x01`\x01`\xA0\x1B\x03\x82\x16`\x80R`\xA0\x81\x90Ra\0b3a\0kV[PPPPa\x03\x0CV[`\x01`\x01`\xA0\x1B\x03\x16c\x8Bx\xC6\xD8\x19\x81\x90U\x80_\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x81\x80\xA3PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\0\xC9W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\0\xE2Wa\0\xE2a\0\xA6V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x01\x10Wa\x01\x10a\0\xA6V[`@R\x81\x81R\x83\x82\x01` \x01\x85\x10\x15a\x01'W__\xFD[\x81` \x85\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[____`\x80\x85\x87\x03\x12\x15a\x01VW__\xFD[\x84Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01kW__\xFD[a\x01w\x87\x82\x88\x01a\0\xBAV[` \x87\x01Q\x90\x95P\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01\x94W__\xFD[a\x01\xA0\x87\x82\x88\x01a\0\xBAV[`@\x87\x01Q\x90\x94P\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x01\xBEW__\xFD[``\x95\x90\x95\x01Q\x93\x96\x92\x95PPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x01\xE2W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x02\0WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x02MW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x02+WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x02JW_\x81U`\x01\x01a\x027V[PP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02kWa\x02ka\0\xA6V[a\x02\x7F\x81a\x02y\x84Ta\x01\xCEV[\x84a\x02\x06V[` `\x1F\x82\x11`\x01\x81\x14a\x02\xB1W_\x83\x15a\x02\x9AWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x02JV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x02\xE0W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x02\xC0V[P\x84\x82\x10\x15a\x02\xFDW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[`\x80Q`\xA0Qa\r\x1Aa\x03-_9_a\x03n\x01R_a\x02G\x01Ra\r\x1A_\xF3\xFE`\x80`@R`\x046\x10a\x01<W_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xB3W\x80c\xC0GM\x0B\x11a\0mW\x80c\xC0GM\x0B\x14a\x03]W\x80c\xD5\x05\xAC\xCF\x14a\x03\x90W\x80c\xDDb\xED>\x14a\x03\xAFW\x80c\xF0N(>\x14a\x03\xCEW\x80c\xF2\xFD\xE3\x8B\x14a\x03\xE1W\x80c\xFE\xE8\x1C\xF4\x14a\x03\xF4W__\xFD[\x80cqP\x18\xA6\x14a\x02\xBAW\x80c~\xCE\xBE\0\x14a\x02\xC2W\x80c\x8D\xA5\xCB[\x14a\x02\xF3W\x80c\x95\xD8\x9BA\x14a\x03\x0BW\x80c\x9D\xC2\x9F\xAC\x14a\x03\x1FW\x80c\xA9\x05\x9C\xBB\x14a\x03>W__\xFD[\x80c1<\xE5g\x11a\x01\x04W\x80c1<\xE5g\x14a\x01\xE8W\x80c6D\xE5\x15\x14a\x02\x03W\x80c@\xC1\x0F\x19\x14a\x02\x17W\x80cH\0\xD9\x7F\x14a\x026W\x80cT\xD1\xF1=\x14a\x02\x81W\x80cp\xA0\x821\x14a\x02\x89W__\xFD[\x80c\x06\xFD\xDE\x03\x14a\x01@W\x80c\t^\xA7\xB3\x14a\x01jW\x80c\x18\x16\r\xDD\x14a\x01\x99W\x80c#\xB8r\xDD\x14a\x01\xBFW\x80c%i)b\x14a\x01\xDEW[__\xFD[4\x80\x15a\x01KW__\xFD[Pa\x01Ta\x04%V[`@Qa\x01a\x91\x90a\x0B\x1CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01uW__\xFD[Pa\x01\x89a\x01\x846`\x04a\x0BlV[a\x04\xB4V[`@Q\x90\x15\x15\x81R` \x01a\x01aV[4\x80\x15a\x01\xA4W__\xFD[Ph\x054\\\xDFw\xEBh\xF4LT[`@Q\x90\x81R` \x01a\x01aV[4\x80\x15a\x01\xCAW__\xFD[Pa\x01\x89a\x01\xD96`\x04a\x0B\x94V[a\x054V[a\x01\xE6a\x05\xF0V[\0[4\x80\x15a\x01\xF3W__\xFD[P`@Q`\x12\x81R` \x01a\x01aV[4\x80\x15a\x02\x0EW__\xFD[Pa\x01\xB1a\x06=V[4\x80\x15a\x02\"W__\xFD[Pa\x01\xE6a\x0216`\x04a\x0BlV[a\x06\xB9V[4\x80\x15a\x02AW__\xFD[Pa\x02i\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01aV[a\x01\xE6a\x06\xCFV[4\x80\x15a\x02\x94W__\xFD[Pa\x01\xB1a\x02\xA36`\x04a\x0B\xCEV[c\x87\xA2\x11\xA2`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[a\x01\xE6a\x07\x08V[4\x80\x15a\x02\xCDW__\xFD[Pa\x01\xB1a\x02\xDC6`\x04a\x0B\xCEV[c87u\x08`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[4\x80\x15a\x02\xFEW__\xFD[Pc\x8Bx\xC6\xD8\x19Ta\x02iV[4\x80\x15a\x03\x16W__\xFD[Pa\x01Ta\x07\x1BV[4\x80\x15a\x03*W__\xFD[Pa\x01\xE6a\x0396`\x04a\x0BlV[a\x07*V[4\x80\x15a\x03IW__\xFD[Pa\x01\x89a\x03X6`\x04a\x0BlV[a\x07<V[4\x80\x15a\x03hW__\xFD[Pa\x01\xB1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x03\x9BW__\xFD[Pa\x01\xE6a\x03\xAA6`\x04a\x0B\xEEV[a\x07\xA0V[4\x80\x15a\x03\xBAW__\xFD[Pa\x01\xB1a\x03\xC96`\x04a\x0C[V[a\tTV[a\x01\xE6a\x03\xDC6`\x04a\x0B\xCEV[a\t\x98V[a\x01\xE6a\x03\xEF6`\x04a\x0B\xCEV[a\t\xD5V[4\x80\x15a\x03\xFFW__\xFD[Pa\x01\xB1a\x04\x0E6`\x04a\x0B\xCEV[c8\x9Au\xE1`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[``_\x80Ta\x043\x90a\x0C\x8CV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x04_\x90a\x0C\x8CV[\x80\x15a\x04\xAAW\x80`\x1F\x10a\x04\x81Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x04\xAAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x04\x8DW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_`\x01`\x01`\xA0\x1B\x03\x83\x16n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3\x18\x82\x19\x15\x17a\x04\xE5Wc?hS\x9A_R`\x04`\x1C\xFD[\x82` Rc\x7F^\x9F `\x0CR3_R\x81`4`\x0C U\x81_R`,Q``\x1C3\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%` _\xA3P`\x01[\x92\x91PPV[_\x83``\x1Bn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA33\x14a\x05\x89W3` Rc\x7F^\x9F \x81\x17`\x0CR`4`\x0C \x80T\x80\x19\x15a\x05\x86W\x80\x85\x11\x15a\x05\x80Wc\x13\xBE%+_R`\x04`\x1C\xFD[\x84\x81\x03\x82U[PP[c\x87\xA2\x11\xA2\x81\x17`\x0CR` `\x0C \x80T\x80\x85\x11\x15a\x05\xAFWc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x84\x81\x03\x82UPP\x83_R` `\x0C \x83\x81T\x01\x81UP\x82` R`\x0CQ``\x1C\x81``\x1C_Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3PP`\x01\x93\x92PPPV[_b\x02\xA3\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16B\x01\x90Pc8\x9Au\xE1`\x0CR3_R\x80` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D__\xA2PV[_\x80a\x06Ga\x04%V[\x80Q\x90` \x01 \x90P`@\x80Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R` \x81\x01\x92\x90\x92R\x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6\x90\x82\x01RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 \x91\x90PV[a\x06\xC1a\t\xFBV[a\x06\xCB\x82\x82a\n\x15V[PPV[c8\x9Au\xE1`\x0CR3_R_` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92__\xA2V[a\x07\x10a\t\xFBV[a\x07\x19_a\n~V[V[```\x01\x80Ta\x043\x90a\x0C\x8CV[a\x072a\t\xFBV[a\x06\xCB\x82\x82a\n\xBBV[_c\x87\xA2\x11\xA2`\x0CR3_R` `\x0C \x80T\x80\x84\x11\x15a\x07dWc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x83\x81\x03\x82UPP\x82_R` `\x0C \x82\x81T\x01\x81UP\x81` R`\x0CQ``\x1C3_Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3P`\x01\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x86\x16n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3\x18\x85\x19\x15\x17a\x07\xD0Wc?hS\x9A_R`\x04`\x1C\xFD[_a\x07\xD9a\x04%V[\x80Q\x90` \x01 \x90P\x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6B\x86\x10\x15a\x08\x18Wc\x1A\x15\xA3\xCC_R`\x04`\x1C\xFD[`@Q\x89``\x1B``\x1C\x99P\x88``\x1B``\x1C\x98Pe87u\x08\x19\x01`\x0ER\x89_R` `\x0C \x80T\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x83R\x84` \x84\x01R\x83`@\x84\x01RF``\x84\x01R0`\x80\x84\x01R`\xA0\x83 `.R\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x83R\x8B` \x84\x01R\x8A`@\x84\x01R\x89``\x84\x01R\x80`\x80\x84\x01R\x88`\xA0\x84\x01R`\xC0\x83 `NR`B`, _R\x87`\xFF\x16` R\x86`@R\x85``R` \x80`\x80_`\x01Z\xFA\x8C=Q\x14a\t\0Wc\xDD\xAF\xBA\xEF_R`\x04`\x1C\xFD[\x01\x90Uc\x03\xFA\xF4\xF9`\xA5\x1B\x89\x17`@R`4`, \x88\x90U\x88\x8A\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%` ``\x85\x01\xA3`@RPP_``RPPPPPPPV[_n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA2\x19`\x01`\x01`\xA0\x1B\x03\x83\x16\x01a\t}WP_\x19a\x05.V[P` Rc\x7F^\x9F `\x0C\x90\x81R_\x91\x90\x91R`4\x90 T\x90V[a\t\xA0a\t\xFBV[c8\x9Au\xE1`\x0CR\x80_R` `\x0C \x80TB\x11\x15a\t\xC6Wco^\x88\x18_R`\x04`\x1C\xFD[_\x90Ua\t\xD2\x81a\n~V[PV[a\t\xDDa\t\xFBV[\x80``\x1Ba\t\xF2WctH\xFB\xAE_R`\x04`\x1C\xFD[a\t\xD2\x81a\n~V[c\x8Bx\xC6\xD8\x19T3\x14a\x07\x19Wc\x82\xB4)\0_R`\x04`\x1C\xFD[h\x054\\\xDFw\xEBh\xF4LT\x81\x81\x01\x81\x81\x10\x15a\n8Wc\xE5\xCF\xE9W_R`\x04`\x1C\xFD[\x80h\x054\\\xDFw\xEBh\xF4LUPPc\x87\xA2\x11\xA2`\x0CR\x81_R` `\x0C \x81\x81T\x01\x81UP\x80` R`\x0CQ``\x1C__Q` a\x0C\xC5_9_Q\x90_R` \x80\xA3PPV[c\x8Bx\xC6\xD8\x19\x80T`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x82\x90\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3UV[c\x87\xA2\x11\xA2`\x0CR\x81_R` `\x0C \x80T\x80\x83\x11\x15a\n\xE2Wc\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x82\x90\x03\x90Uh\x054\\\xDFw\xEBh\xF4L\x80T\x82\x90\x03\x90U_\x81\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16_Q` a\x0C\xC5_9_Q\x90_R` \x83\xA3PPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0BgW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a\x0B}W__\xFD[a\x0B\x86\x83a\x0BQV[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a\x0B\xA6W__\xFD[a\x0B\xAF\x84a\x0BQV[\x92Pa\x0B\xBD` \x85\x01a\x0BQV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_` \x82\x84\x03\x12\x15a\x0B\xDEW__\xFD[a\x0B\xE7\x82a\x0BQV[\x93\x92PPPV[_______`\xE0\x88\x8A\x03\x12\x15a\x0C\x04W__\xFD[a\x0C\r\x88a\x0BQV[\x96Pa\x0C\x1B` \x89\x01a\x0BQV[\x95P`@\x88\x015\x94P``\x88\x015\x93P`\x80\x88\x015`\xFF\x81\x16\x81\x14a\x0C>W__\xFD[\x96\x99\x95\x98P\x93\x96\x92\x95\x94`\xA0\x84\x015\x94P`\xC0\x90\x93\x015\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x0ClW__\xFD[a\x0Cu\x83a\x0BQV[\x91Pa\x0C\x83` \x84\x01a\x0BQV[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0C\xA0W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x0C\xBEWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV\xFE\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\xA2dipfsX\"\x12 \xF2U\x8A\xD4F\x0C\xA0\x0E\xBE\xBA\xB8\xD0#r\xDDk\x02\x7F\x19\xDE{\xD9\xD72\xADt\xC5\xCF$c_EdsolcC\0\x08\x1E\x003\xA2dipfsX\"\x12 \x91\x9D\xE7\xB4Y\r\xF5k\xC1\x1A\xEB0O\xA2\x9D{D\x14_5\x084\x1D\xC0\xA2\x0C\x84\xEE\xAB5\x8D\x15dsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Resolution(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Resolution> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl Resolution {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for Resolution {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<Resolution> for u8 {
            fn from(value: Resolution) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Resolution {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Resolution {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidMarketState()` and selector `0x473ba95a`.
```solidity
error InvalidMarketState();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidMarketState;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidMarketState> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidMarketState) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidMarketState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidMarketState {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidMarketState()";
            const SELECTOR: [u8; 4] = [71u8, 59u8, 169u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidResolution()` and selector `0xe4adec8a`.
```solidity
error InvalidResolution();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidResolution;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidResolution> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidResolution) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidResolution {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidResolution {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidResolution()";
            const SELECTOR: [u8; 4] = [228u8, 173u8, 236u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidVerse()` and selector `0x40fe50fd`.
```solidity
error InvalidVerse();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidVerse;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidVerse> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidVerse) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidVerse {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidVerse {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidVerse()";
            const SELECTOR: [u8; 4] = [64u8, 254u8, 80u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `MarketAlreadyOpened()` and selector `0x6f4b7b36`.
```solidity
error MarketAlreadyOpened();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MarketAlreadyOpened;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MarketAlreadyOpened> for UnderlyingRustTuple<'_> {
            fn from(value: MarketAlreadyOpened) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MarketAlreadyOpened {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MarketAlreadyOpened {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MarketAlreadyOpened()";
            const SELECTOR: [u8; 4] = [111u8, 75u8, 123u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Combined(address,address,bytes32,uint256,address,address)` and selector `0x9a853bfbdd6034e0e7553bb8ec7789b2603dcccb5759cf390a7a601c0b6da003`.
```solidity
event Combined(address indexed user, address indexed asset, bytes32 indexed marketHash, uint256 amount, address yesVerse, address noVerse);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Combined {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub yesVerse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub noVerse: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Combined {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "Combined(address,address,bytes32,uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                154u8, 133u8, 59u8, 251u8, 221u8, 96u8, 52u8, 224u8, 231u8, 85u8, 59u8,
                184u8, 236u8, 119u8, 137u8, 178u8, 96u8, 61u8, 204u8, 203u8, 87u8, 89u8,
                207u8, 57u8, 10u8, 122u8, 96u8, 28u8, 11u8, 109u8, 160u8, 3u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    asset: topics.2,
                    marketHash: topics.3,
                    amount: data.0,
                    yesVerse: data.1,
                    noVerse: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.yesVerse,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.noVerse,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.user.clone(),
                    self.asset.clone(),
                    self.marketHash.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Combined {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Combined> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Combined) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `MarketOpened(bytes32,bytes32,uint32,address)` and selector `0x094eba69d7ca9dfafa34c896067fc8e19395a610e47deb8b25b21b87bec32a34`.
```solidity
event MarketOpened(bytes32 indexed marketHash, bytes32 indexed questionHash, uint32 resolutionDeadline, address indexed oracle);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MarketOpened {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub questionHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub resolutionDeadline: u32,
        #[allow(missing_docs)]
        pub oracle: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MarketOpened {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "MarketOpened(bytes32,bytes32,uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                9u8, 78u8, 186u8, 105u8, 215u8, 202u8, 157u8, 250u8, 250u8, 52u8, 200u8,
                150u8, 6u8, 127u8, 200u8, 225u8, 147u8, 149u8, 166u8, 16u8, 228u8, 125u8,
                235u8, 139u8, 37u8, 178u8, 27u8, 135u8, 190u8, 195u8, 42u8, 52u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    marketHash: topics.1,
                    questionHash: topics.2,
                    resolutionDeadline: data.0,
                    oracle: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.resolutionDeadline),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.marketHash.clone(),
                    self.questionHash.clone(),
                    self.oracle.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.questionHash);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oracle,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MarketOpened {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MarketOpened> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MarketOpened) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `MarketResolved(bytes32,uint8)` and selector `0xf34984473148051bc1bdf1be6ecc462d7b228d591058a8a27977b84770b738b9`.
```solidity
event MarketResolved(bytes32 indexed marketHash, Resolution resolution);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MarketResolved {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub resolution: <Resolution as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MarketResolved {
            type DataTuple<'a> = (Resolution,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "MarketResolved(bytes32,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                243u8, 73u8, 132u8, 71u8, 49u8, 72u8, 5u8, 27u8, 193u8, 189u8, 241u8,
                190u8, 110u8, 204u8, 70u8, 45u8, 123u8, 34u8, 141u8, 89u8, 16u8, 88u8,
                168u8, 162u8, 121u8, 119u8, 184u8, 71u8, 112u8, 183u8, 56u8, 185u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    marketHash: topics.1,
                    resolution: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<Resolution as alloy_sol_types::SolType>::tokenize(&self.resolution),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.marketHash.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MarketResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MarketResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MarketResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Redeemed(address,address,bytes32,uint256,uint256)` and selector `0xae1d804a86b6ba2a7725d9824d4ccb4e7f9a55e7a1bf4379c26692ce5ad00665`.
```solidity
event Redeemed(address indexed user, address indexed verse, bytes32 indexed marketHash, uint256 amount, uint256 redeemedAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Redeemed {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub verse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub redeemedAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Redeemed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "Redeemed(address,address,bytes32,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                174u8, 29u8, 128u8, 74u8, 134u8, 182u8, 186u8, 42u8, 119u8, 37u8, 217u8,
                130u8, 77u8, 76u8, 203u8, 78u8, 127u8, 154u8, 85u8, 231u8, 161u8, 191u8,
                67u8, 121u8, 194u8, 102u8, 146u8, 206u8, 90u8, 208u8, 6u8, 101u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    verse: topics.2,
                    marketHash: topics.3,
                    amount: data.0,
                    redeemedAmount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.redeemedAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.user.clone(),
                    self.verse.clone(),
                    self.marketHash.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.verse,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Redeemed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Redeemed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Redeemed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Split(address,address,bytes32,uint256,address,address)` and selector `0x8fb8a329bc68853568e0dd27c6aee2e361a1f07892cf65ab49cc2f30cd21c3c5`.
```solidity
event Split(address indexed user, address indexed asset, bytes32 indexed marketHash, uint256 amount, address yesVerse, address noVerse);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Split {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub yesVerse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub noVerse: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Split {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "Split(address,address,bytes32,uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                143u8, 184u8, 163u8, 41u8, 188u8, 104u8, 133u8, 53u8, 104u8, 224u8,
                221u8, 39u8, 198u8, 174u8, 226u8, 227u8, 97u8, 161u8, 240u8, 120u8,
                146u8, 207u8, 101u8, 171u8, 73u8, 204u8, 47u8, 48u8, 205u8, 33u8, 195u8,
                197u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    asset: topics.2,
                    marketHash: topics.3,
                    amount: data.0,
                    yesVerse: data.1,
                    noVerse: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.yesVerse,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.noVerse,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.user.clone(),
                    self.asset.clone(),
                    self.marketHash.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Split {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Split> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Split) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `VerseTokensCreated(bytes32,address,address,address)` and selector `0x9e431caef5753e3e939653fc056c910725980029b3653db5a36bebca71d6bc2c`.
```solidity
event VerseTokensCreated(bytes32 indexed marketHash, address indexed asset, address yesVerse, address noVerse);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct VerseTokensCreated {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub yesVerse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub noVerse: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for VerseTokensCreated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "VerseTokensCreated(bytes32,address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                158u8, 67u8, 28u8, 174u8, 245u8, 117u8, 62u8, 62u8, 147u8, 150u8, 83u8,
                252u8, 5u8, 108u8, 145u8, 7u8, 37u8, 152u8, 0u8, 41u8, 179u8, 101u8,
                61u8, 181u8, 163u8, 107u8, 235u8, 202u8, 113u8, 214u8, 188u8, 44u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    marketHash: topics.1,
                    asset: topics.2,
                    yesVerse: data.0,
                    noVerse: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.yesVerse,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.noVerse,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.marketHash.clone(),
                    self.asset.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.marketHash);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for VerseTokensCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&VerseTokensCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &VerseTokensCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `combine(address,uint256,bytes32)` and selector `0x41055a76`.
```solidity
function combine(address asset, uint256 amount, bytes32 marketHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct combineCall {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`combine(address,uint256,bytes32)`](combineCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct combineReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<combineCall> for UnderlyingRustTuple<'_> {
                fn from(value: combineCall) -> Self {
                    (value.asset, value.amount, value.marketHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for combineCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                        marketHash: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<combineReturn> for UnderlyingRustTuple<'_> {
                fn from(value: combineReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for combineReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl combineReturn {
            fn _tokenize(
                &self,
            ) -> <combineCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for combineCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = combineReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "combine(address,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [65u8, 5u8, 90u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                combineReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `create(address,bytes32)` and selector `0xa3def923`.
```solidity
function create(address asset, bytes32 marketHash) external returns (address yesVerse, address noVerse);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createCall {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`create(address,bytes32)`](createCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createReturn {
        #[allow(missing_docs)]
        pub yesVerse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub noVerse: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createCall> for UnderlyingRustTuple<'_> {
                fn from(value: createCall) -> Self {
                    (value.asset, value.marketHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        marketHash: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createReturn) -> Self {
                    (value.yesVerse, value.noVerse)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        yesVerse: tuple.0,
                        noVerse: tuple.1,
                    }
                }
            }
        }
        impl createReturn {
            fn _tokenize(
                &self,
            ) -> <createCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.yesVerse,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.noVerse,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "create(address,bytes32)";
            const SELECTOR: [u8; 4] = [163u8, 222u8, 249u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVerseAddress(address,bytes32)` and selector `0xe9739550`.
```solidity
function getVerseAddress(address asset, bytes32 marketHash) external view returns (address yesVerse, address noVerse);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVerseAddressCall {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVerseAddress(address,bytes32)`](getVerseAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVerseAddressReturn {
        #[allow(missing_docs)]
        pub yesVerse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub noVerse: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVerseAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVerseAddressCall) -> Self {
                    (value.asset, value.marketHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVerseAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        marketHash: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVerseAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVerseAddressReturn) -> Self {
                    (value.yesVerse, value.noVerse)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVerseAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        yesVerse: tuple.0,
                        noVerse: tuple.1,
                    }
                }
            }
        }
        impl getVerseAddressReturn {
            fn _tokenize(
                &self,
            ) -> <getVerseAddressCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.yesVerse,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.noVerse,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVerseAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVerseAddressReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVerseAddress(address,bytes32)";
            const SELECTOR: [u8; 4] = [233u8, 115u8, 149u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getVerseAddressReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isVerse(address)` and selector `0x7183d24a`.
```solidity
function isVerse(address verse) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isVerseCall {
        #[allow(missing_docs)]
        pub verse: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isVerse(address)`](isVerseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isVerseReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isVerseCall> for UnderlyingRustTuple<'_> {
                fn from(value: isVerseCall) -> Self {
                    (value.verse,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isVerseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { verse: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isVerseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isVerseReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isVerseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isVerseCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isVerse(address)";
            const SELECTOR: [u8; 4] = [113u8, 131u8, 210u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.verse,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isVerseReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isVerseReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `markets(bytes32)` and selector `0x7564912b`.
```solidity
function markets(bytes32 marketHash) external view returns (uint32 resolutionDeadline, address oracle, bytes32 questionHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct marketsCall {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`markets(bytes32)`](marketsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct marketsReturn {
        #[allow(missing_docs)]
        pub resolutionDeadline: u32,
        #[allow(missing_docs)]
        pub oracle: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub questionHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<marketsCall> for UnderlyingRustTuple<'_> {
                fn from(value: marketsCall) -> Self {
                    (value.marketHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for marketsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { marketHash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<marketsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: marketsReturn) -> Self {
                    (value.resolutionDeadline, value.oracle, value.questionHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for marketsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        resolutionDeadline: tuple.0,
                        oracle: tuple.1,
                        questionHash: tuple.2,
                    }
                }
            }
        }
        impl marketsReturn {
            fn _tokenize(
                &self,
            ) -> <marketsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.resolutionDeadline),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oracle,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.questionHash),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for marketsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = marketsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "markets(bytes32)";
            const SELECTOR: [u8; 4] = [117u8, 100u8, 145u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                marketsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `open(bytes32,uint32,address)` and selector `0xc2a33c1d`.
```solidity
function open(bytes32 questionHash, uint32 resolutionDeadline, address oracle) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct openCall {
        #[allow(missing_docs)]
        pub questionHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub resolutionDeadline: u32,
        #[allow(missing_docs)]
        pub oracle: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`open(bytes32,uint32,address)`](openCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct openReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<openCall> for UnderlyingRustTuple<'_> {
                fn from(value: openCall) -> Self {
                    (value.questionHash, value.resolutionDeadline, value.oracle)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for openCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        questionHash: tuple.0,
                        resolutionDeadline: tuple.1,
                        oracle: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<openReturn> for UnderlyingRustTuple<'_> {
                fn from(value: openReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for openReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl openReturn {
            fn _tokenize(
                &self,
            ) -> <openCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for openCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = openReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "open(bytes32,uint32,address)";
            const SELECTOR: [u8; 4] = [194u8, 163u8, 60u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.questionHash),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.resolutionDeadline),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oracle,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                openReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `redeem(address,uint256)` and selector `0x1e9a6950`.
```solidity
function redeem(address verse, uint256 amount) external returns (uint256 redeemedAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct redeemCall {
        #[allow(missing_docs)]
        pub verse: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`redeem(address,uint256)`](redeemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct redeemReturn {
        #[allow(missing_docs)]
        pub redeemedAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<redeemCall> for UnderlyingRustTuple<'_> {
                fn from(value: redeemCall) -> Self {
                    (value.verse, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for redeemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        verse: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<redeemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: redeemReturn) -> Self {
                    (value.redeemedAmount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for redeemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { redeemedAmount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for redeemCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "redeem(address,uint256)";
            const SELECTOR: [u8; 4] = [30u8, 154u8, 105u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.verse,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: redeemReturn = r.into();
                        r.redeemedAmount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: redeemReturn = r.into();
                        r.redeemedAmount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `resolutions(bytes32)` and selector `0xd4b06fb8`.
```solidity
function resolutions(bytes32 marketHash) external view returns (Resolution);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolutionsCall {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`resolutions(bytes32)`](resolutionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolutionsReturn {
        #[allow(missing_docs)]
        pub _0: <Resolution as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolutionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resolutionsCall) -> Self {
                    (value.marketHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolutionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { marketHash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Resolution,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Resolution as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolutionsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resolutionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolutionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolutionsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Resolution as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Resolution,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolutions(bytes32)";
            const SELECTOR: [u8; 4] = [212u8, 176u8, 111u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Resolution as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: resolutionsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: resolutionsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `resolve(bytes32)` and selector `0x5c23bdf5`.
```solidity
function resolve(bytes32 marketHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveCall {
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`resolve(bytes32)`](resolveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveCall> for UnderlyingRustTuple<'_> {
                fn from(value: resolveCall) -> Self {
                    (value.marketHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { marketHash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resolveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl resolveReturn {
            fn _tokenize(
                &self,
            ) -> <resolveCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolve(bytes32)";
            const SELECTOR: [u8; 4] = [92u8, 35u8, 189u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                resolveReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `split(address,uint256,bytes32)` and selector `0x9ba730a9`.
```solidity
function split(address asset, uint256 amount, bytes32 marketHash) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitCall {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub marketHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`split(address,uint256,bytes32)`](splitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitCall> for UnderlyingRustTuple<'_> {
                fn from(value: splitCall) -> Self {
                    (value.asset, value.amount, value.marketHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                        marketHash: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: splitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl splitReturn {
            fn _tokenize(
                &self,
            ) -> <splitCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for splitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = splitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "split(address,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [155u8, 167u8, 48u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.marketHash),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                splitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MultiVerse`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum MultiVerseCalls {
        #[allow(missing_docs)]
        combine(combineCall),
        #[allow(missing_docs)]
        create(createCall),
        #[allow(missing_docs)]
        getVerseAddress(getVerseAddressCall),
        #[allow(missing_docs)]
        isVerse(isVerseCall),
        #[allow(missing_docs)]
        markets(marketsCall),
        #[allow(missing_docs)]
        open(openCall),
        #[allow(missing_docs)]
        redeem(redeemCall),
        #[allow(missing_docs)]
        resolutions(resolutionsCall),
        #[allow(missing_docs)]
        resolve(resolveCall),
        #[allow(missing_docs)]
        split(splitCall),
    }
    impl MultiVerseCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [30u8, 154u8, 105u8, 80u8],
            [65u8, 5u8, 90u8, 118u8],
            [92u8, 35u8, 189u8, 245u8],
            [113u8, 131u8, 210u8, 74u8],
            [117u8, 100u8, 145u8, 43u8],
            [155u8, 167u8, 48u8, 169u8],
            [163u8, 222u8, 249u8, 35u8],
            [194u8, 163u8, 60u8, 29u8],
            [212u8, 176u8, 111u8, 184u8],
            [233u8, 115u8, 149u8, 80u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(redeem),
            ::core::stringify!(combine),
            ::core::stringify!(resolve),
            ::core::stringify!(isVerse),
            ::core::stringify!(markets),
            ::core::stringify!(split),
            ::core::stringify!(create),
            ::core::stringify!(open),
            ::core::stringify!(resolutions),
            ::core::stringify!(getVerseAddress),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <redeemCall as alloy_sol_types::SolCall>::SIGNATURE,
            <combineCall as alloy_sol_types::SolCall>::SIGNATURE,
            <resolveCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isVerseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <marketsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <splitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createCall as alloy_sol_types::SolCall>::SIGNATURE,
            <openCall as alloy_sol_types::SolCall>::SIGNATURE,
            <resolutionsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getVerseAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MultiVerseCalls {
        const NAME: &'static str = "MultiVerseCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::combine(_) => <combineCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::create(_) => <createCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVerseAddress(_) => {
                    <getVerseAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isVerse(_) => <isVerseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::markets(_) => <marketsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::open(_) => <openCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::redeem(_) => <redeemCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::resolutions(_) => {
                    <resolutionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolve(_) => <resolveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::split(_) => <splitCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiVerseCalls>] = &[
                {
                    fn redeem(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <redeemCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::redeem)
                    }
                    redeem
                },
                {
                    fn combine(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <combineCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::combine)
                    }
                    combine
                },
                {
                    fn resolve(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <resolveCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::resolve)
                    }
                    resolve
                },
                {
                    fn isVerse(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <isVerseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::isVerse)
                    }
                    isVerse
                },
                {
                    fn markets(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <marketsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::markets)
                    }
                    markets
                },
                {
                    fn split(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <splitCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::split)
                    }
                    split
                },
                {
                    fn create(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <createCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::create)
                    }
                    create
                },
                {
                    fn open(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <openCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiVerseCalls::open)
                    }
                    open
                },
                {
                    fn resolutions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <resolutionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiVerseCalls::resolutions)
                    }
                    resolutions
                },
                {
                    fn getVerseAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <getVerseAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiVerseCalls::getVerseAddress)
                    }
                    getVerseAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiVerseCalls>] = &[
                {
                    fn redeem(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <redeemCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::redeem)
                    }
                    redeem
                },
                {
                    fn combine(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <combineCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::combine)
                    }
                    combine
                },
                {
                    fn resolve(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <resolveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::resolve)
                    }
                    resolve
                },
                {
                    fn isVerse(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <isVerseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::isVerse)
                    }
                    isVerse
                },
                {
                    fn markets(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <marketsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::markets)
                    }
                    markets
                },
                {
                    fn split(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <splitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::split)
                    }
                    split
                },
                {
                    fn create(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <createCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::create)
                    }
                    create
                },
                {
                    fn open(data: &[u8]) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <openCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::open)
                    }
                    open
                },
                {
                    fn resolutions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <resolutionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::resolutions)
                    }
                    resolutions
                },
                {
                    fn getVerseAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseCalls> {
                        <getVerseAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseCalls::getVerseAddress)
                    }
                    getVerseAddress
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::combine(inner) => {
                    <combineCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::create(inner) => {
                    <createCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVerseAddress(inner) => {
                    <getVerseAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isVerse(inner) => {
                    <isVerseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::markets(inner) => {
                    <marketsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::open(inner) => {
                    <openCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::redeem(inner) => {
                    <redeemCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::resolutions(inner) => {
                    <resolutionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolve(inner) => {
                    <resolveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::split(inner) => {
                    <splitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::combine(inner) => {
                    <combineCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::create(inner) => {
                    <createCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getVerseAddress(inner) => {
                    <getVerseAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isVerse(inner) => {
                    <isVerseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::markets(inner) => {
                    <marketsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::open(inner) => {
                    <openCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::redeem(inner) => {
                    <redeemCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::resolutions(inner) => {
                    <resolutionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolve(inner) => {
                    <resolveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::split(inner) => {
                    <splitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`MultiVerse`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum MultiVerseErrors {
        #[allow(missing_docs)]
        InvalidMarketState(InvalidMarketState),
        #[allow(missing_docs)]
        InvalidResolution(InvalidResolution),
        #[allow(missing_docs)]
        InvalidVerse(InvalidVerse),
        #[allow(missing_docs)]
        MarketAlreadyOpened(MarketAlreadyOpened),
    }
    impl MultiVerseErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [64u8, 254u8, 80u8, 253u8],
            [71u8, 59u8, 169u8, 90u8],
            [111u8, 75u8, 123u8, 54u8],
            [228u8, 173u8, 236u8, 138u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(InvalidVerse),
            ::core::stringify!(InvalidMarketState),
            ::core::stringify!(MarketAlreadyOpened),
            ::core::stringify!(InvalidResolution),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <InvalidVerse as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidMarketState as alloy_sol_types::SolError>::SIGNATURE,
            <MarketAlreadyOpened as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidResolution as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MultiVerseErrors {
        const NAME: &'static str = "MultiVerseErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::InvalidMarketState(_) => {
                    <InvalidMarketState as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidResolution(_) => {
                    <InvalidResolution as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidVerse(_) => {
                    <InvalidVerse as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MarketAlreadyOpened(_) => {
                    <MarketAlreadyOpened as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiVerseErrors>] = &[
                {
                    fn InvalidVerse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidVerse as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiVerseErrors::InvalidVerse)
                    }
                    InvalidVerse
                },
                {
                    fn InvalidMarketState(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidMarketState as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiVerseErrors::InvalidMarketState)
                    }
                    InvalidMarketState
                },
                {
                    fn MarketAlreadyOpened(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <MarketAlreadyOpened as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiVerseErrors::MarketAlreadyOpened)
                    }
                    MarketAlreadyOpened
                },
                {
                    fn InvalidResolution(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidResolution as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiVerseErrors::InvalidResolution)
                    }
                    InvalidResolution
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiVerseErrors>] = &[
                {
                    fn InvalidVerse(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidVerse as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseErrors::InvalidVerse)
                    }
                    InvalidVerse
                },
                {
                    fn InvalidMarketState(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidMarketState as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseErrors::InvalidMarketState)
                    }
                    InvalidMarketState
                },
                {
                    fn MarketAlreadyOpened(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <MarketAlreadyOpened as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseErrors::MarketAlreadyOpened)
                    }
                    MarketAlreadyOpened
                },
                {
                    fn InvalidResolution(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiVerseErrors> {
                        <InvalidResolution as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiVerseErrors::InvalidResolution)
                    }
                    InvalidResolution
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::InvalidMarketState(inner) => {
                    <InvalidMarketState as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidResolution(inner) => {
                    <InvalidResolution as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidVerse(inner) => {
                    <InvalidVerse as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::MarketAlreadyOpened(inner) => {
                    <MarketAlreadyOpened as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::InvalidMarketState(inner) => {
                    <InvalidMarketState as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidResolution(inner) => {
                    <InvalidResolution as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidVerse(inner) => {
                    <InvalidVerse as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MarketAlreadyOpened(inner) => {
                    <MarketAlreadyOpened as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MultiVerse`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum MultiVerseEvents {
        #[allow(missing_docs)]
        Combined(Combined),
        #[allow(missing_docs)]
        MarketOpened(MarketOpened),
        #[allow(missing_docs)]
        MarketResolved(MarketResolved),
        #[allow(missing_docs)]
        Redeemed(Redeemed),
        #[allow(missing_docs)]
        Split(Split),
        #[allow(missing_docs)]
        VerseTokensCreated(VerseTokensCreated),
    }
    impl MultiVerseEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                9u8, 78u8, 186u8, 105u8, 215u8, 202u8, 157u8, 250u8, 250u8, 52u8, 200u8,
                150u8, 6u8, 127u8, 200u8, 225u8, 147u8, 149u8, 166u8, 16u8, 228u8, 125u8,
                235u8, 139u8, 37u8, 178u8, 27u8, 135u8, 190u8, 195u8, 42u8, 52u8,
            ],
            [
                143u8, 184u8, 163u8, 41u8, 188u8, 104u8, 133u8, 53u8, 104u8, 224u8,
                221u8, 39u8, 198u8, 174u8, 226u8, 227u8, 97u8, 161u8, 240u8, 120u8,
                146u8, 207u8, 101u8, 171u8, 73u8, 204u8, 47u8, 48u8, 205u8, 33u8, 195u8,
                197u8,
            ],
            [
                154u8, 133u8, 59u8, 251u8, 221u8, 96u8, 52u8, 224u8, 231u8, 85u8, 59u8,
                184u8, 236u8, 119u8, 137u8, 178u8, 96u8, 61u8, 204u8, 203u8, 87u8, 89u8,
                207u8, 57u8, 10u8, 122u8, 96u8, 28u8, 11u8, 109u8, 160u8, 3u8,
            ],
            [
                158u8, 67u8, 28u8, 174u8, 245u8, 117u8, 62u8, 62u8, 147u8, 150u8, 83u8,
                252u8, 5u8, 108u8, 145u8, 7u8, 37u8, 152u8, 0u8, 41u8, 179u8, 101u8,
                61u8, 181u8, 163u8, 107u8, 235u8, 202u8, 113u8, 214u8, 188u8, 44u8,
            ],
            [
                174u8, 29u8, 128u8, 74u8, 134u8, 182u8, 186u8, 42u8, 119u8, 37u8, 217u8,
                130u8, 77u8, 76u8, 203u8, 78u8, 127u8, 154u8, 85u8, 231u8, 161u8, 191u8,
                67u8, 121u8, 194u8, 102u8, 146u8, 206u8, 90u8, 208u8, 6u8, 101u8,
            ],
            [
                243u8, 73u8, 132u8, 71u8, 49u8, 72u8, 5u8, 27u8, 193u8, 189u8, 241u8,
                190u8, 110u8, 204u8, 70u8, 45u8, 123u8, 34u8, 141u8, 89u8, 16u8, 88u8,
                168u8, 162u8, 121u8, 119u8, 184u8, 71u8, 112u8, 183u8, 56u8, 185u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(MarketOpened),
            ::core::stringify!(Split),
            ::core::stringify!(Combined),
            ::core::stringify!(VerseTokensCreated),
            ::core::stringify!(Redeemed),
            ::core::stringify!(MarketResolved),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <MarketOpened as alloy_sol_types::SolEvent>::SIGNATURE,
            <Split as alloy_sol_types::SolEvent>::SIGNATURE,
            <Combined as alloy_sol_types::SolEvent>::SIGNATURE,
            <VerseTokensCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <Redeemed as alloy_sol_types::SolEvent>::SIGNATURE,
            <MarketResolved as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MultiVerseEvents {
        const NAME: &'static str = "MultiVerseEvents";
        const COUNT: usize = 6usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Combined as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Combined as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Combined)
                }
                Some(<MarketOpened as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MarketOpened as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::MarketOpened)
                }
                Some(<MarketResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MarketResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::MarketResolved)
                }
                Some(<Redeemed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Redeemed as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Redeemed)
                }
                Some(<Split as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Split as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Split)
                }
                Some(
                    <VerseTokensCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <VerseTokensCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::VerseTokensCreated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MultiVerseEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Combined(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MarketOpened(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MarketResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Redeemed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Split(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::VerseTokensCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Combined(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MarketOpened(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MarketResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Redeemed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Split(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::VerseTokensCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MultiVerse`](self) contract instance.

See the [wrapper's documentation](`MultiVerseInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> MultiVerseInstance<P, N> {
        MultiVerseInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MultiVerseInstance<P, N>>,
    > {
        MultiVerseInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        MultiVerseInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`MultiVerse`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MultiVerse`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MultiVerseInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for MultiVerseInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MultiVerseInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiVerseInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`MultiVerse`](self) contract instance.

See the [wrapper's documentation](`MultiVerseInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<MultiVerseInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> MultiVerseInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MultiVerseInstance<P, N> {
            MultiVerseInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiVerseInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`combine`] function.
        pub fn combine(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, combineCall, N> {
            self.call_builder(
                &combineCall {
                    asset,
                    amount,
                    marketHash,
                },
            )
        }
        ///Creates a new call builder for the [`create`] function.
        pub fn create(
            &self,
            asset: alloy::sol_types::private::Address,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, createCall, N> {
            self.call_builder(&createCall { asset, marketHash })
        }
        ///Creates a new call builder for the [`getVerseAddress`] function.
        pub fn getVerseAddress(
            &self,
            asset: alloy::sol_types::private::Address,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getVerseAddressCall, N> {
            self.call_builder(
                &getVerseAddressCall {
                    asset,
                    marketHash,
                },
            )
        }
        ///Creates a new call builder for the [`isVerse`] function.
        pub fn isVerse(
            &self,
            verse: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isVerseCall, N> {
            self.call_builder(&isVerseCall { verse })
        }
        ///Creates a new call builder for the [`markets`] function.
        pub fn markets(
            &self,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, marketsCall, N> {
            self.call_builder(&marketsCall { marketHash })
        }
        ///Creates a new call builder for the [`open`] function.
        pub fn open(
            &self,
            questionHash: alloy::sol_types::private::FixedBytes<32>,
            resolutionDeadline: u32,
            oracle: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, openCall, N> {
            self.call_builder(
                &openCall {
                    questionHash,
                    resolutionDeadline,
                    oracle,
                },
            )
        }
        ///Creates a new call builder for the [`redeem`] function.
        pub fn redeem(
            &self,
            verse: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, redeemCall, N> {
            self.call_builder(&redeemCall { verse, amount })
        }
        ///Creates a new call builder for the [`resolutions`] function.
        pub fn resolutions(
            &self,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, resolutionsCall, N> {
            self.call_builder(&resolutionsCall { marketHash })
        }
        ///Creates a new call builder for the [`resolve`] function.
        pub fn resolve(
            &self,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, resolveCall, N> {
            self.call_builder(&resolveCall { marketHash })
        }
        ///Creates a new call builder for the [`split`] function.
        pub fn split(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            marketHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, splitCall, N> {
            self.call_builder(
                &splitCall {
                    asset,
                    amount,
                    marketHash,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiVerseInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Combined`] event.
        pub fn Combined_filter(&self) -> alloy_contract::Event<&P, Combined, N> {
            self.event_filter::<Combined>()
        }
        ///Creates a new event filter for the [`MarketOpened`] event.
        pub fn MarketOpened_filter(&self) -> alloy_contract::Event<&P, MarketOpened, N> {
            self.event_filter::<MarketOpened>()
        }
        ///Creates a new event filter for the [`MarketResolved`] event.
        pub fn MarketResolved_filter(
            &self,
        ) -> alloy_contract::Event<&P, MarketResolved, N> {
            self.event_filter::<MarketResolved>()
        }
        ///Creates a new event filter for the [`Redeemed`] event.
        pub fn Redeemed_filter(&self) -> alloy_contract::Event<&P, Redeemed, N> {
            self.event_filter::<Redeemed>()
        }
        ///Creates a new event filter for the [`Split`] event.
        pub fn Split_filter(&self) -> alloy_contract::Event<&P, Split, N> {
            self.event_filter::<Split>()
        }
        ///Creates a new event filter for the [`VerseTokensCreated`] event.
        pub fn VerseTokensCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, VerseTokensCreated, N> {
            self.event_filter::<VerseTokensCreated>()
        }
    }
}
